#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
use libc;
extern crate core;

/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201605;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 24;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const _MATH_H_MATHDEF: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const SX1280_DEBUG: u32 = 0;
pub const XTAL_FREQ: u32 = 52000000;
pub const AUTO_RX_TX_OFFSET: u32 = 33;
pub const REG_LR_FIRMWARE_VERSION_MSB: u32 = 339;
pub const REG_LR_CRCSEEDBASEADDR: u32 = 2504;
pub const REG_LR_CRCPOLYBASEADDR: u32 = 2502;
pub const REG_LR_WHITSEEDBASEADDR: u32 = 2501;
pub const REG_LR_RANGINGIDCHECKLENGTH: u32 = 2353;
pub const REG_LR_DEVICERANGINGADDR: u32 = 2326;
pub const REG_LR_REQUESTRANGINGADDR: u32 = 2322;
pub const REG_LR_RANGINGRESULTCONFIG: u32 = 2340;
pub const MASK_RANGINGMUXSEL: u32 = 207;
pub const REG_LR_RANGINGRESULTBASEADDR: u32 = 2401;
pub const REG_LR_RANGINGRESULTSFREEZE: u32 = 2431;
pub const REG_LR_RANGINGRERXTXDELAYCAL: u32 = 2348;
pub const REG_LR_RANGINGFILTERWINDOWSIZE: u32 = 2334;
pub const REG_LR_RANGINGRESULTCLEARREG: u32 = 2339;
pub const REG_RANGING_RSSI: u32 = 2404;
pub const DEFAULT_RANGING_FILTER_SIZE: u32 = 127;
pub const REG_LR_PACKETPARAMS: u32 = 2307;
pub const REG_LR_PAYLOADLENGTH: u32 = 2305;
pub const IRAM_START_ADDRESS: u32 = 32768;
pub const IRAM_SIZE: u32 = 16384;
pub const REG_LR_SYNCWORDBASEADDRESS1: u32 = 2510;
pub const REG_LR_SYNCWORDBASEADDRESS2: u32 = 2515;
pub const REG_LR_SYNCWORDBASEADDRESS3: u32 = 2520;
pub const REG_LR_ESTIMATED_FREQUENCY_ERROR_MSB: u32 = 2388;
pub const REG_LR_ESTIMATED_FREQUENCY_ERROR_MASK: u32 = 1048575;
pub const REG_LR_SYNCWORDTOLERANCE: u32 = 2509;
pub const REG_LR_BLE_ACCESS_ADDRESS: u32 = 2511;
pub const BLE_ADVERTIZER_ACCESS_ADDRESS: u32 = 2391391958;
pub const REG_LNA_REGIME: u32 = 2193;
pub const MASK_LNA_REGIME: u32 = 192;
pub const REG_ENABLE_MANUAL_GAIN_CONTROL: u32 = 2207;
pub const MASK_MANUAL_GAIN_CONTROL: u32 = 128;
pub const REG_DEMOD_DETECTION: u32 = 2197;
pub const MASK_DEMOD_DETECTION: u32 = 254;
pub const REG_MANUAL_GAIN_VALUE: u32 = 2206;
pub const MASK_MANUAL_GAIN_VALUE: u32 = 240;
pub type int_least8_t = libc::c_schar;
pub type int_least16_t = libc::c_short;
pub type int_least32_t = libc::c_int;
pub type int_least64_t = libc::c_long;
pub type uint_least8_t = libc::c_uchar;
pub type uint_least16_t = libc::c_ushort;
pub type uint_least32_t = libc::c_uint;
pub type uint_least64_t = libc::c_ulong;
pub type int_fast8_t = libc::c_schar;
pub type int_fast16_t = libc::c_long;
pub type int_fast32_t = libc::c_long;
pub type int_fast64_t = libc::c_long;
pub type uint_fast8_t = libc::c_uchar;
pub type uint_fast16_t = libc::c_ulong;
pub type uint_fast32_t = libc::c_ulong;
pub type uint_fast64_t = libc::c_ulong;
pub type intmax_t = libc::c_long;
pub type uintmax_t = libc::c_ulong;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn isinf(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn isnan(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassify(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: libc::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn isinff(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn isnanf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: libc::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: f64) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: libc::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> libc::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: libc::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> libc::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> libc::c_int;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanl(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2l(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanl(__x: f64) -> f64;
}
extern "C" {
    pub fn coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __coshl(__x: f64) -> f64;
}
extern "C" {
    pub fn sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn __acoshl(__x: f64) -> f64;
}
extern "C" {
    pub fn asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinhl(__x: f64) -> f64;
}
extern "C" {
    pub fn atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanhl(__x: f64) -> f64;
}
extern "C" {
    pub fn expl(__x: f64) -> f64;
}
extern "C" {
    pub fn __expl(__x: f64) -> f64;
}
extern "C" {
    pub fn frexpl(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __frexpl(__x: f64, __exponent: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexpl(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn __ldexpl(__x: f64, __exponent: libc::c_int) -> f64;
}
extern "C" {
    pub fn logl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logl(__x: f64) -> f64;
}
extern "C" {
    pub fn log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10l(__x: f64) -> f64;
}
extern "C" {
    pub fn modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modfl(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1l(__x: f64) -> f64;
}
extern "C" {
    pub fn log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1pl(__x: f64) -> f64;
}
extern "C" {
    pub fn logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn __logbl(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2l(__x: f64) -> f64;
}
extern "C" {
    pub fn log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2l(__x: f64) -> f64;
}
extern "C" {
    pub fn powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __powl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypotl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrtl(__x: f64) -> f64;
}
extern "C" {
    pub fn ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceill(__x: f64) -> f64;
}
extern "C" {
    pub fn fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabsl(__x: f64) -> f64;
}
extern "C" {
    pub fn floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn __floorl(__x: f64) -> f64;
}
extern "C" {
    pub fn fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmodl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __isinfl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __finitel(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn isinfl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn finitel(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __dreml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn __significandl(__x: f64) -> f64;
}
extern "C" {
    pub fn copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysignl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nanl(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __nanl(__tagb: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn __isnanl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn isnanl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn jnl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jnl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0l(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1l(arg1: f64) -> f64;
}
extern "C" {
    pub fn ynl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __ynl(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfl(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfcl(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gammal(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgammal_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __lgammal_r(arg1: f64, __signgamp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __rintl(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafterl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nexttowardl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainderl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbnl(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn __scalbnl(__x: f64, __n: libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogbl(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: f64) -> libc::c_int;
}
extern "C" {
    pub fn scalblnl(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn __scalblnl(__x: f64, __n: libc::c_long) -> f64;
}
extern "C" {
    pub fn nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyintl(__x: f64) -> f64;
}
extern "C" {
    pub fn roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn __roundl(__x: f64) -> f64;
}
extern "C" {
    pub fn truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn __truncl(__x: f64) -> f64;
}
extern "C" {
    pub fn remquol(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn __remquol(__x: f64, __y: f64, __quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn lrintl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lrintl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrintl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn __lroundl(__x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llroundl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdiml(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmaxl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fminl(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbitl(__value: f64) -> libc::c_int;
}
extern "C" {
    pub fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fmal(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalbl(__x: f64, __n: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}signgam"]
    pub static mut signgam: libc::c_int;
}
pub const FP_NAN: _bindgen_ty_1 = 0;
pub const FP_INFINITE: _bindgen_ty_1 = 1;
pub const FP_ZERO: _bindgen_ty_1 = 2;
pub const FP_SUBNORMAL: _bindgen_ty_1 = 3;
pub const FP_NORMAL: _bindgen_ty_1 = 4;
pub type _bindgen_ty_1 = u32;
pub const _LIB_VERSION_TYPE__IEEE_: _LIB_VERSION_TYPE = -1;
pub const _LIB_VERSION_TYPE__SVID_: _LIB_VERSION_TYPE = 0;
pub const _LIB_VERSION_TYPE__XOPEN_: _LIB_VERSION_TYPE = 1;
pub const _LIB_VERSION_TYPE__POSIX_: _LIB_VERSION_TYPE = 2;
pub const _LIB_VERSION_TYPE__ISOC_: _LIB_VERSION_TYPE = 3;
pub type _LIB_VERSION_TYPE = i32;
extern "C" {
    #[link_name = "\u{1}_LIB_VERSION"]
    pub static mut _LIB_VERSION: _LIB_VERSION_TYPE;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: libc::c_int,
    pub name: *mut libc::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        ::core::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::core::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    pub fn matherr(__exc: *mut exception) -> libc::c_int;
}
pub type Reset = ::core::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void)>;
pub type DelayMs = ::core::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void, ms: u32)>;
pub type WriteBuffer = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut libc::c_void, addr: u8, buffer: *mut u8, size: u8),
>;
pub type ReadBuffer = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut libc::c_void, addr: u8, buffer: *mut u8, size: u8),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SX1280_s {
    pub ctx: *mut libc::c_void,
    pub reset: Reset,
    pub delay_ms: DelayMs,
    pub write_buffer: WriteBuffer,
    pub read_buffer: ReadBuffer,
}
#[test]
fn bindgen_test_layout_SX1280_s() {
    assert_eq!(
        ::core::mem::size_of::<SX1280_s>(),
        40usize,
        concat!("Size of: ", stringify!(SX1280_s))
    );
    assert_eq!(
        ::core::mem::align_of::<SX1280_s>(),
        8usize,
        concat!("Alignment of ", stringify!(SX1280_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).reset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).delay_ms as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(delay_ms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).write_buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(write_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).read_buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(read_buffer)
        )
    );
}
pub type SX1280_t = SX1280_s;
pub type DioIrqHandler = ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>;
pub const RadioLnaSettings_t_LNA_LOW_POWER_MODE: RadioLnaSettings_t = 0;
pub const RadioLnaSettings_t_LNA_HIGH_SENSITIVITY_MODE: RadioLnaSettings_t = 1;
pub type RadioLnaSettings_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union RadioStatus_t {
    pub Fields: RadioStatus_t__bindgen_ty_1,
    pub Value: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RadioStatus_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RadioStatus_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RadioStatus_t__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RadioStatus_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RadioStatus_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(RadioStatus_t__bindgen_ty_1))
    );
}
impl RadioStatus_t__bindgen_ty_1 {
    #[inline]
    pub fn CpuBusy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CpuBusy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DmaBusy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DmaBusy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CmdStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CmdStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ChipMode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_ChipMode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CpuBusy: u8,
        DmaBusy: u8,
        CmdStatus: u8,
        ChipMode: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CpuBusy: u8 = unsafe { ::core::mem::transmute(CpuBusy) };
            CpuBusy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DmaBusy: u8 = unsafe { ::core::mem::transmute(DmaBusy) };
            DmaBusy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let CmdStatus: u8 = unsafe { ::core::mem::transmute(CmdStatus) };
            CmdStatus as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let ChipMode: u8 = unsafe { ::core::mem::transmute(ChipMode) };
            ChipMode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RadioStatus_t() {
    assert_eq!(
        ::core::mem::size_of::<RadioStatus_t>(),
        1usize,
        concat!("Size of: ", stringify!(RadioStatus_t))
    );
    assert_eq!(
        ::core::mem::align_of::<RadioStatus_t>(),
        1usize,
        concat!("Alignment of ", stringify!(RadioStatus_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioStatus_t>())).Fields as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioStatus_t),
            "::",
            stringify!(Fields)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioStatus_t>())).Value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioStatus_t),
            "::",
            stringify!(Value)
        )
    );
}
pub const RadioStates_t_RF_IDLE: RadioStates_t = 0;
pub const RadioStates_t_RF_RX_RUNNING: RadioStates_t = 1;
pub const RadioStates_t_RF_TX_RUNNING: RadioStates_t = 2;
pub const RadioStates_t_RF_CAD: RadioStates_t = 3;
pub type RadioStates_t = u32;
pub const RadioOperatingModes_t_MODE_SLEEP: RadioOperatingModes_t = 0;
pub const RadioOperatingModes_t_MODE_STDBY_RC: RadioOperatingModes_t = 1;
pub const RadioOperatingModes_t_MODE_STDBY_XOSC: RadioOperatingModes_t = 2;
pub const RadioOperatingModes_t_MODE_FS: RadioOperatingModes_t = 3;
pub const RadioOperatingModes_t_MODE_TX: RadioOperatingModes_t = 4;
pub const RadioOperatingModes_t_MODE_RX: RadioOperatingModes_t = 5;
pub const RadioOperatingModes_t_MODE_CAD: RadioOperatingModes_t = 6;
pub type RadioOperatingModes_t = u32;
pub const RadioStandbyModes_t_STDBY_RC: RadioStandbyModes_t = 0;
pub const RadioStandbyModes_t_STDBY_XOSC: RadioStandbyModes_t = 1;
pub type RadioStandbyModes_t = u32;
pub const RadioRegulatorModes_t_USE_LDO: RadioRegulatorModes_t = 0;
pub const RadioRegulatorModes_t_USE_DCDC: RadioRegulatorModes_t = 1;
pub type RadioRegulatorModes_t = u32;
pub const RadioPacketTypes_t_PACKET_TYPE_GFSK: RadioPacketTypes_t = 0;
pub const RadioPacketTypes_t_PACKET_TYPE_LORA: RadioPacketTypes_t = 1;
pub const RadioPacketTypes_t_PACKET_TYPE_RANGING: RadioPacketTypes_t = 2;
pub const RadioPacketTypes_t_PACKET_TYPE_FLRC: RadioPacketTypes_t = 3;
pub const RadioPacketTypes_t_PACKET_TYPE_BLE: RadioPacketTypes_t = 4;
pub const RadioPacketTypes_t_PACKET_TYPE_NONE: RadioPacketTypes_t = 15;
pub type RadioPacketTypes_t = u32;
pub const RadioRampTimes_t_RADIO_RAMP_02_US: RadioRampTimes_t = 0;
pub const RadioRampTimes_t_RADIO_RAMP_04_US: RadioRampTimes_t = 32;
pub const RadioRampTimes_t_RADIO_RAMP_06_US: RadioRampTimes_t = 64;
pub const RadioRampTimes_t_RADIO_RAMP_08_US: RadioRampTimes_t = 96;
pub const RadioRampTimes_t_RADIO_RAMP_10_US: RadioRampTimes_t = 128;
pub const RadioRampTimes_t_RADIO_RAMP_12_US: RadioRampTimes_t = 160;
pub const RadioRampTimes_t_RADIO_RAMP_16_US: RadioRampTimes_t = 192;
pub const RadioRampTimes_t_RADIO_RAMP_20_US: RadioRampTimes_t = 224;
pub type RadioRampTimes_t = u32;
pub const RadioLoRaCadSymbols_t_LORA_CAD_01_SYMBOL: RadioLoRaCadSymbols_t = 0;
pub const RadioLoRaCadSymbols_t_LORA_CAD_02_SYMBOL: RadioLoRaCadSymbols_t = 32;
pub const RadioLoRaCadSymbols_t_LORA_CAD_04_SYMBOL: RadioLoRaCadSymbols_t = 64;
pub const RadioLoRaCadSymbols_t_LORA_CAD_08_SYMBOL: RadioLoRaCadSymbols_t = 96;
pub const RadioLoRaCadSymbols_t_LORA_CAD_16_SYMBOL: RadioLoRaCadSymbols_t = 128;
pub type RadioLoRaCadSymbols_t = u32;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_2_000_BW_2_4: RadioGfskBleBitrates_t = 4;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_1_600_BW_2_4: RadioGfskBleBitrates_t = 40;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_1_000_BW_2_4: RadioGfskBleBitrates_t = 76;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_1_000_BW_1_2: RadioGfskBleBitrates_t = 69;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_800_BW_2_4: RadioGfskBleBitrates_t = 112;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_800_BW_1_2: RadioGfskBleBitrates_t = 105;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_500_BW_1_2: RadioGfskBleBitrates_t = 141;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_500_BW_0_6: RadioGfskBleBitrates_t = 134;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_400_BW_1_2: RadioGfskBleBitrates_t = 177;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_400_BW_0_6: RadioGfskBleBitrates_t = 170;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_250_BW_0_6: RadioGfskBleBitrates_t = 206;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_250_BW_0_3: RadioGfskBleBitrates_t = 199;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_125_BW_0_3: RadioGfskBleBitrates_t = 239;
pub type RadioGfskBleBitrates_t = u32;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_0_35: RadioGfskBleModIndexes_t = 0;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_0_50: RadioGfskBleModIndexes_t = 1;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_0_75: RadioGfskBleModIndexes_t = 2;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_1_00: RadioGfskBleModIndexes_t = 3;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_1_25: RadioGfskBleModIndexes_t = 4;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_1_50: RadioGfskBleModIndexes_t = 5;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_1_75: RadioGfskBleModIndexes_t = 6;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_2_00: RadioGfskBleModIndexes_t = 7;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_2_25: RadioGfskBleModIndexes_t = 8;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_2_50: RadioGfskBleModIndexes_t = 9;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_2_75: RadioGfskBleModIndexes_t = 10;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_3_00: RadioGfskBleModIndexes_t = 11;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_3_25: RadioGfskBleModIndexes_t = 12;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_3_50: RadioGfskBleModIndexes_t = 13;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_3_75: RadioGfskBleModIndexes_t = 14;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_4_00: RadioGfskBleModIndexes_t = 15;
pub type RadioGfskBleModIndexes_t = u32;
pub const RadioFlrcBitrates_t_FLRC_BR_2_600_BW_2_4: RadioFlrcBitrates_t = 4;
pub const RadioFlrcBitrates_t_FLRC_BR_2_080_BW_2_4: RadioFlrcBitrates_t = 40;
pub const RadioFlrcBitrates_t_FLRC_BR_1_300_BW_1_2: RadioFlrcBitrates_t = 69;
pub const RadioFlrcBitrates_t_FLRC_BR_1_040_BW_1_2: RadioFlrcBitrates_t = 105;
pub const RadioFlrcBitrates_t_FLRC_BR_0_650_BW_0_6: RadioFlrcBitrates_t = 134;
pub const RadioFlrcBitrates_t_FLRC_BR_0_520_BW_0_6: RadioFlrcBitrates_t = 170;
pub const RadioFlrcBitrates_t_FLRC_BR_0_325_BW_0_3: RadioFlrcBitrates_t = 199;
pub const RadioFlrcBitrates_t_FLRC_BR_0_260_BW_0_3: RadioFlrcBitrates_t = 235;
pub type RadioFlrcBitrates_t = u32;
pub const RadioFlrcCodingRates_t_FLRC_CR_1_2: RadioFlrcCodingRates_t = 0;
pub const RadioFlrcCodingRates_t_FLRC_CR_3_4: RadioFlrcCodingRates_t = 2;
pub const RadioFlrcCodingRates_t_FLRC_CR_1_0: RadioFlrcCodingRates_t = 4;
pub type RadioFlrcCodingRates_t = u32;
pub const RadioModShapings_t_RADIO_MOD_SHAPING_BT_OFF: RadioModShapings_t = 0;
pub const RadioModShapings_t_RADIO_MOD_SHAPING_BT_1_0: RadioModShapings_t = 16;
pub const RadioModShapings_t_RADIO_MOD_SHAPING_BT_0_5: RadioModShapings_t = 32;
pub type RadioModShapings_t = u32;
pub const RadioLoRaSpreadingFactors_t_LORA_SF5: RadioLoRaSpreadingFactors_t = 80;
pub const RadioLoRaSpreadingFactors_t_LORA_SF6: RadioLoRaSpreadingFactors_t = 96;
pub const RadioLoRaSpreadingFactors_t_LORA_SF7: RadioLoRaSpreadingFactors_t = 112;
pub const RadioLoRaSpreadingFactors_t_LORA_SF8: RadioLoRaSpreadingFactors_t = 128;
pub const RadioLoRaSpreadingFactors_t_LORA_SF9: RadioLoRaSpreadingFactors_t = 144;
pub const RadioLoRaSpreadingFactors_t_LORA_SF10: RadioLoRaSpreadingFactors_t = 160;
pub const RadioLoRaSpreadingFactors_t_LORA_SF11: RadioLoRaSpreadingFactors_t = 176;
pub const RadioLoRaSpreadingFactors_t_LORA_SF12: RadioLoRaSpreadingFactors_t = 192;
pub type RadioLoRaSpreadingFactors_t = u32;
pub const RadioLoRaBandwidths_t_LORA_BW_0200: RadioLoRaBandwidths_t = 52;
pub const RadioLoRaBandwidths_t_LORA_BW_0400: RadioLoRaBandwidths_t = 38;
pub const RadioLoRaBandwidths_t_LORA_BW_0800: RadioLoRaBandwidths_t = 24;
pub const RadioLoRaBandwidths_t_LORA_BW_1600: RadioLoRaBandwidths_t = 10;
pub type RadioLoRaBandwidths_t = u32;
pub const RadioLoRaCodingRates_t_LORA_CR_4_5: RadioLoRaCodingRates_t = 1;
pub const RadioLoRaCodingRates_t_LORA_CR_4_6: RadioLoRaCodingRates_t = 2;
pub const RadioLoRaCodingRates_t_LORA_CR_4_7: RadioLoRaCodingRates_t = 3;
pub const RadioLoRaCodingRates_t_LORA_CR_4_8: RadioLoRaCodingRates_t = 4;
pub const RadioLoRaCodingRates_t_LORA_CR_LI_4_5: RadioLoRaCodingRates_t = 5;
pub const RadioLoRaCodingRates_t_LORA_CR_LI_4_6: RadioLoRaCodingRates_t = 6;
pub const RadioLoRaCodingRates_t_LORA_CR_LI_4_7: RadioLoRaCodingRates_t = 7;
pub type RadioLoRaCodingRates_t = u32;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_04_BITS: RadioPreambleLengths_t = 0;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_08_BITS: RadioPreambleLengths_t = 16;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_12_BITS: RadioPreambleLengths_t = 32;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_16_BITS: RadioPreambleLengths_t = 48;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_20_BITS: RadioPreambleLengths_t = 64;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_24_BITS: RadioPreambleLengths_t = 80;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_28_BITS: RadioPreambleLengths_t = 96;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_32_BITS: RadioPreambleLengths_t = 112;
pub type RadioPreambleLengths_t = u32;
pub const RadioFlrcSyncWordLengths_t_FLRC_NO_SYNCWORD: RadioFlrcSyncWordLengths_t = 0;
pub const RadioFlrcSyncWordLengths_t_FLRC_SYNCWORD_LENGTH_4_BYTE: RadioFlrcSyncWordLengths_t = 4;
pub type RadioFlrcSyncWordLengths_t = u32;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_1_BYTE: RadioSyncWordLengths_t = 0;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_2_BYTE: RadioSyncWordLengths_t = 2;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_3_BYTE: RadioSyncWordLengths_t = 4;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_4_BYTE: RadioSyncWordLengths_t = 6;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_5_BYTE: RadioSyncWordLengths_t = 8;
pub type RadioSyncWordLengths_t = u32;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_OFF: RadioSyncWordRxMatchs_t = 0;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_1: RadioSyncWordRxMatchs_t = 16;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_2: RadioSyncWordRxMatchs_t = 32;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_1_2: RadioSyncWordRxMatchs_t = 48;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_3: RadioSyncWordRxMatchs_t = 64;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_1_3: RadioSyncWordRxMatchs_t = 80;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_2_3: RadioSyncWordRxMatchs_t = 96;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_1_2_3: RadioSyncWordRxMatchs_t = 112;
pub type RadioSyncWordRxMatchs_t = u32;
pub const RadioPacketLengthModes_t_RADIO_PACKET_FIXED_LENGTH: RadioPacketLengthModes_t = 0;
pub const RadioPacketLengthModes_t_RADIO_PACKET_VARIABLE_LENGTH: RadioPacketLengthModes_t = 32;
pub type RadioPacketLengthModes_t = u32;
pub const RadioCrcTypes_t_RADIO_CRC_OFF: RadioCrcTypes_t = 0;
pub const RadioCrcTypes_t_RADIO_CRC_1_BYTES: RadioCrcTypes_t = 16;
pub const RadioCrcTypes_t_RADIO_CRC_2_BYTES: RadioCrcTypes_t = 32;
pub const RadioCrcTypes_t_RADIO_CRC_3_BYTES: RadioCrcTypes_t = 48;
pub type RadioCrcTypes_t = u32;
pub const RadioWhiteningModes_t_RADIO_WHITENING_ON: RadioWhiteningModes_t = 0;
pub const RadioWhiteningModes_t_RADIO_WHITENING_OFF: RadioWhiteningModes_t = 8;
pub type RadioWhiteningModes_t = u32;
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_VARIABLE_LENGTH: RadioLoRaPacketLengthsModes_t =
    0;
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_FIXED_LENGTH: RadioLoRaPacketLengthsModes_t =
    128;
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_EXPLICIT: RadioLoRaPacketLengthsModes_t = 0;
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_IMPLICIT: RadioLoRaPacketLengthsModes_t = 128;
pub type RadioLoRaPacketLengthsModes_t = u32;
pub const RadioLoRaCrcModes_t_LORA_CRC_ON: RadioLoRaCrcModes_t = 32;
pub const RadioLoRaCrcModes_t_LORA_CRC_OFF: RadioLoRaCrcModes_t = 0;
pub type RadioLoRaCrcModes_t = u32;
pub const RadioLoRaIQModes_t_LORA_IQ_NORMAL: RadioLoRaIQModes_t = 64;
pub const RadioLoRaIQModes_t_LORA_IQ_INVERTED: RadioLoRaIQModes_t = 0;
pub type RadioLoRaIQModes_t = u32;
pub const RadioRangingIdCheckLengths_t_RANGING_IDCHECK_LENGTH_08_BITS:
    RadioRangingIdCheckLengths_t = 0;
pub const RadioRangingIdCheckLengths_t_RANGING_IDCHECK_LENGTH_16_BITS:
    RadioRangingIdCheckLengths_t = 1;
pub const RadioRangingIdCheckLengths_t_RANGING_IDCHECK_LENGTH_24_BITS:
    RadioRangingIdCheckLengths_t = 2;
pub const RadioRangingIdCheckLengths_t_RANGING_IDCHECK_LENGTH_32_BITS:
    RadioRangingIdCheckLengths_t = 3;
pub type RadioRangingIdCheckLengths_t = u32;
pub const RadioRangingResultTypes_t_RANGING_RESULT_RAW: RadioRangingResultTypes_t = 0;
pub const RadioRangingResultTypes_t_RANGING_RESULT_AVERAGED: RadioRangingResultTypes_t = 1;
pub const RadioRangingResultTypes_t_RANGING_RESULT_DEBIASED: RadioRangingResultTypes_t = 2;
pub const RadioRangingResultTypes_t_RANGING_RESULT_FILTERED: RadioRangingResultTypes_t = 3;
pub type RadioRangingResultTypes_t = u32;
pub const RadioBleConnectionStates_t_BLE_PAYLOAD_LENGTH_MAX_31_BYTES: RadioBleConnectionStates_t =
    0;
pub const RadioBleConnectionStates_t_BLE_PAYLOAD_LENGTH_MAX_37_BYTES: RadioBleConnectionStates_t =
    32;
pub const RadioBleConnectionStates_t_BLE_TX_TEST_MODE: RadioBleConnectionStates_t = 64;
pub const RadioBleConnectionStates_t_BLE_PAYLOAD_LENGTH_MAX_255_BYTES: RadioBleConnectionStates_t =
    128;
pub type RadioBleConnectionStates_t = u32;
pub const RadioBleCrcFields_t_BLE_CRC_OFF: RadioBleCrcFields_t = 0;
pub const RadioBleCrcFields_t_BLE_CRC_3B: RadioBleCrcFields_t = 16;
pub type RadioBleCrcFields_t = u32;
pub const RadioBlePacketTypes_t_BLE_PRBS_9: RadioBlePacketTypes_t = 0;
pub const RadioBlePacketTypes_t_BLE_PRBS_15: RadioBlePacketTypes_t = 12;
pub const RadioBlePacketTypes_t_BLE_EYELONG_1_0: RadioBlePacketTypes_t = 4;
pub const RadioBlePacketTypes_t_BLE_EYELONG_0_1: RadioBlePacketTypes_t = 24;
pub const RadioBlePacketTypes_t_BLE_EYESHORT_1_0: RadioBlePacketTypes_t = 8;
pub const RadioBlePacketTypes_t_BLE_EYESHORT_0_1: RadioBlePacketTypes_t = 28;
pub const RadioBlePacketTypes_t_BLE_ALL_1: RadioBlePacketTypes_t = 16;
pub const RadioBlePacketTypes_t_BLE_ALL_0: RadioBlePacketTypes_t = 20;
pub type RadioBlePacketTypes_t = u32;
pub const RadioIrqMasks_t_IRQ_RADIO_NONE: RadioIrqMasks_t = 0;
pub const RadioIrqMasks_t_IRQ_TX_DONE: RadioIrqMasks_t = 1;
pub const RadioIrqMasks_t_IRQ_RX_DONE: RadioIrqMasks_t = 2;
pub const RadioIrqMasks_t_IRQ_SYNCWORD_VALID: RadioIrqMasks_t = 4;
pub const RadioIrqMasks_t_IRQ_SYNCWORD_ERROR: RadioIrqMasks_t = 8;
pub const RadioIrqMasks_t_IRQ_HEADER_VALID: RadioIrqMasks_t = 16;
pub const RadioIrqMasks_t_IRQ_HEADER_ERROR: RadioIrqMasks_t = 32;
pub const RadioIrqMasks_t_IRQ_CRC_ERROR: RadioIrqMasks_t = 64;
pub const RadioIrqMasks_t_IRQ_RANGING_SLAVE_RESPONSE_DONE: RadioIrqMasks_t = 128;
pub const RadioIrqMasks_t_IRQ_RANGING_SLAVE_REQUEST_DISCARDED: RadioIrqMasks_t = 256;
pub const RadioIrqMasks_t_IRQ_RANGING_MASTER_RESULT_VALID: RadioIrqMasks_t = 512;
pub const RadioIrqMasks_t_IRQ_RANGING_MASTER_RESULT_TIMEOUT: RadioIrqMasks_t = 1024;
pub const RadioIrqMasks_t_IRQ_RANGING_SLAVE_REQUEST_VALID: RadioIrqMasks_t = 2048;
pub const RadioIrqMasks_t_IRQ_CAD_DONE: RadioIrqMasks_t = 4096;
pub const RadioIrqMasks_t_IRQ_CAD_ACTIVITY_DETECTED: RadioIrqMasks_t = 8192;
pub const RadioIrqMasks_t_IRQ_RX_TX_TIMEOUT: RadioIrqMasks_t = 16384;
pub const RadioIrqMasks_t_IRQ_PREAMBLE_DETECTED: RadioIrqMasks_t = 32768;
pub const RadioIrqMasks_t_IRQ_RADIO_ALL: RadioIrqMasks_t = 65535;
pub type RadioIrqMasks_t = u32;
pub const RadioDios_t_RADIO_DIO1: RadioDios_t = 2;
pub const RadioDios_t_RADIO_DIO2: RadioDios_t = 4;
pub const RadioDios_t_RADIO_DIO3: RadioDios_t = 8;
pub type RadioDios_t = u32;
pub const RadioTickSizes_t_RADIO_TICK_SIZE_0015_US: RadioTickSizes_t = 0;
pub const RadioTickSizes_t_RADIO_TICK_SIZE_0062_US: RadioTickSizes_t = 1;
pub const RadioTickSizes_t_RADIO_TICK_SIZE_1000_US: RadioTickSizes_t = 2;
pub const RadioTickSizes_t_RADIO_TICK_SIZE_4000_US: RadioTickSizes_t = 3;
pub type RadioTickSizes_t = u32;
pub const RadioRangingRoles_t_RADIO_RANGING_ROLE_SLAVE: RadioRangingRoles_t = 0;
pub const RadioRangingRoles_t_RADIO_RANGING_ROLE_MASTER: RadioRangingRoles_t = 1;
pub type RadioRangingRoles_t = u32;
pub const RadioCommands_u_RADIO_GET_STATUS: RadioCommands_u = 192;
pub const RadioCommands_u_RADIO_WRITE_REGISTER: RadioCommands_u = 24;
pub const RadioCommands_u_RADIO_READ_REGISTER: RadioCommands_u = 25;
pub const RadioCommands_u_RADIO_WRITE_BUFFER: RadioCommands_u = 26;
pub const RadioCommands_u_RADIO_READ_BUFFER: RadioCommands_u = 27;
pub const RadioCommands_u_RADIO_SET_SLEEP: RadioCommands_u = 132;
pub const RadioCommands_u_RADIO_SET_STANDBY: RadioCommands_u = 128;
pub const RadioCommands_u_RADIO_SET_FS: RadioCommands_u = 193;
pub const RadioCommands_u_RADIO_SET_TX: RadioCommands_u = 131;
pub const RadioCommands_u_RADIO_SET_RX: RadioCommands_u = 130;
pub const RadioCommands_u_RADIO_SET_RXDUTYCYCLE: RadioCommands_u = 148;
pub const RadioCommands_u_RADIO_SET_CAD: RadioCommands_u = 197;
pub const RadioCommands_u_RADIO_SET_TXCONTINUOUSWAVE: RadioCommands_u = 209;
pub const RadioCommands_u_RADIO_SET_TXCONTINUOUSPREAMBLE: RadioCommands_u = 210;
pub const RadioCommands_u_RADIO_SET_PACKETTYPE: RadioCommands_u = 138;
pub const RadioCommands_u_RADIO_GET_PACKETTYPE: RadioCommands_u = 3;
pub const RadioCommands_u_RADIO_SET_RFFREQUENCY: RadioCommands_u = 134;
pub const RadioCommands_u_RADIO_SET_TXPARAMS: RadioCommands_u = 142;
pub const RadioCommands_u_RADIO_SET_CADPARAMS: RadioCommands_u = 136;
pub const RadioCommands_u_RADIO_SET_BUFFERBASEADDRESS: RadioCommands_u = 143;
pub const RadioCommands_u_RADIO_SET_MODULATIONPARAMS: RadioCommands_u = 139;
pub const RadioCommands_u_RADIO_SET_PACKETPARAMS: RadioCommands_u = 140;
pub const RadioCommands_u_RADIO_GET_RXBUFFERSTATUS: RadioCommands_u = 23;
pub const RadioCommands_u_RADIO_GET_PACKETSTATUS: RadioCommands_u = 29;
pub const RadioCommands_u_RADIO_GET_RSSIINST: RadioCommands_u = 31;
pub const RadioCommands_u_RADIO_SET_DIOIRQPARAMS: RadioCommands_u = 141;
pub const RadioCommands_u_RADIO_GET_IRQSTATUS: RadioCommands_u = 21;
pub const RadioCommands_u_RADIO_CLR_IRQSTATUS: RadioCommands_u = 151;
pub const RadioCommands_u_RADIO_CALIBRATE: RadioCommands_u = 137;
pub const RadioCommands_u_RADIO_SET_REGULATORMODE: RadioCommands_u = 150;
pub const RadioCommands_u_RADIO_SET_SAVECONTEXT: RadioCommands_u = 213;
pub const RadioCommands_u_RADIO_SET_AUTOTX: RadioCommands_u = 152;
pub const RadioCommands_u_RADIO_SET_AUTOFS: RadioCommands_u = 158;
pub const RadioCommands_u_RADIO_SET_LONGPREAMBLE: RadioCommands_u = 155;
pub const RadioCommands_u_RADIO_SET_UARTSPEED: RadioCommands_u = 157;
pub const RadioCommands_u_RADIO_SET_RANGING_ROLE: RadioCommands_u = 163;
pub type RadioCommands_u = u32;
pub use self::RadioCommands_u as RadioCommands_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TickTime_s {
    pub Step: RadioTickSizes_t,
    pub NbSteps: u16,
}
#[test]
fn bindgen_test_layout_TickTime_s() {
    assert_eq!(
        ::core::mem::size_of::<TickTime_s>(),
        8usize,
        concat!("Size of: ", stringify!(TickTime_s))
    );
    assert_eq!(
        ::core::mem::align_of::<TickTime_s>(),
        4usize,
        concat!("Alignment of ", stringify!(TickTime_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TickTime_s>())).Step as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TickTime_s),
            "::",
            stringify!(Step)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TickTime_s>())).NbSteps as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TickTime_s),
            "::",
            stringify!(NbSteps)
        )
    );
}
pub type TickTime_t = TickTime_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t {
    pub PacketType: RadioPacketTypes_t,
    pub Params: ModulationParams_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1 {
    pub Gfsk: ModulationParams_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: ModulationParams_t__bindgen_ty_1__bindgen_ty_2,
    pub Flrc: ModulationParams_t__bindgen_ty_1__bindgen_ty_3,
    pub Ble: ModulationParams_t__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_1 {
    pub BitrateBandwidth: RadioGfskBleBitrates_t,
    pub ModulationIndex: RadioGfskBleModIndexes_t,
    pub ModulationShaping: RadioModShapings_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>()))
                .BitrateBandwidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BitrateBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>()))
                .ModulationIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ModulationIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>()))
                .ModulationShaping as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ModulationShaping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_2 {
    pub SpreadingFactor: RadioLoRaSpreadingFactors_t,
    pub Bandwidth: RadioLoRaBandwidths_t,
    pub CodingRate: RadioLoRaCodingRates_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>()))
                .SpreadingFactor as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SpreadingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>())).Bandwidth
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Bandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>())).CodingRate
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(CodingRate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_3 {
    pub BitrateBandwidth: RadioFlrcBitrates_t,
    pub CodingRate: RadioFlrcCodingRates_t,
    pub ModulationShaping: RadioModShapings_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>()))
                .BitrateBandwidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(BitrateBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>())).CodingRate
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(CodingRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>()))
                .ModulationShaping as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ModulationShaping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_4 {
    pub BitrateBandwidth: RadioGfskBleBitrates_t,
    pub ModulationIndex: RadioGfskBleModIndexes_t,
    pub ModulationShaping: RadioModShapings_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>()))
                .BitrateBandwidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(BitrateBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>()))
                .ModulationIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ModulationIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>()))
                .ModulationShaping as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ModulationShaping)
        )
    );
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(ModulationParams_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1>())).Gfsk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1),
            "::",
            stringify!(Gfsk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1>())).LoRa as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1),
            "::",
            stringify!(LoRa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1>())).Flrc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1),
            "::",
            stringify!(Flrc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1>())).Ble as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1),
            "::",
            stringify!(Ble)
        )
    );
}
#[test]
fn bindgen_test_layout_ModulationParams_t() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t>(),
        52usize,
        concat!("Size of: ", stringify!(ModulationParams_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ModulationParams_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ModulationParams_t>())).PacketType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t),
            "::",
            stringify!(PacketType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ModulationParams_t>())).Params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t),
            "::",
            stringify!(Params)
        )
    );
}
pub const IrqErrorCode_t_IRQ_HEADER_ERROR_CODE: IrqErrorCode_t = 0;
pub const IrqErrorCode_t_IRQ_SYNCWORD_ERROR_CODE: IrqErrorCode_t = 1;
pub const IrqErrorCode_t_IRQ_CRC_ERROR_CODE: IrqErrorCode_t = 2;
pub const IrqErrorCode_t_IRQ_RANGING_ON_LORA_ERROR_CODE: IrqErrorCode_t = 3;
pub type IrqErrorCode_t = u32;
pub const IrqRangingCode_t_IRQ_RANGING_SLAVE_ERROR_CODE: IrqRangingCode_t = 0;
pub const IrqRangingCode_t_IRQ_RANGING_SLAVE_VALID_CODE: IrqRangingCode_t = 1;
pub const IrqRangingCode_t_IRQ_RANGING_MASTER_ERROR_CODE: IrqRangingCode_t = 2;
pub const IrqRangingCode_t_IRQ_RANGING_MASTER_VALID_CODE: IrqRangingCode_t = 3;
pub type IrqRangingCode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RadioCallbacks_t {
    pub txDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxSyncWordDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxHeaderDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub txTimeout: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxTimeout: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxError: ::core::option::Option<
        unsafe extern "C" fn(sx1280: *mut SX1280_t, errCode: IrqErrorCode_t),
    >,
    pub rangingDone:
        ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t, val: IrqRangingCode_t)>,
    pub cadDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t, cadFlag: bool)>,
}
#[test]
fn bindgen_test_layout_RadioCallbacks_t() {
    assert_eq!(
        ::core::mem::size_of::<RadioCallbacks_t>(),
        72usize,
        concat!("Size of: ", stringify!(RadioCallbacks_t))
    );
    assert_eq!(
        ::core::mem::align_of::<RadioCallbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(RadioCallbacks_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).txDone as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(txDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rxDone as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxDone)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RadioCallbacks_t>())).rxSyncWordDone as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxSyncWordDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rxHeaderDone as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxHeaderDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).txTimeout as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(txTimeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rxTimeout as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxTimeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rxError as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxError)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rangingDone as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rangingDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).cadDone as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(cadDone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t {
    pub PacketType: RadioPacketTypes_t,
    pub Params: PacketParams_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1 {
    pub Gfsk: PacketParams_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: PacketParams_t__bindgen_ty_1__bindgen_ty_2,
    pub Flrc: PacketParams_t__bindgen_ty_1__bindgen_ty_3,
    pub Ble: PacketParams_t__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_1 {
    pub PreambleLength: RadioPreambleLengths_t,
    pub SyncWordLength: RadioSyncWordLengths_t,
    pub SyncWordMatch: RadioSyncWordRxMatchs_t,
    pub HeaderType: RadioPacketLengthModes_t,
    pub PayloadLength: u8,
    pub CrcLength: RadioCrcTypes_t,
    pub Whitening: RadioWhiteningModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).PreambleLength
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(PreambleLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).SyncWordLength
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SyncWordLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).SyncWordMatch
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SyncWordMatch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).HeaderType
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(HeaderType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).PayloadLength
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(PayloadLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).CrcLength
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(CrcLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).Whitening
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Whitening)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_2 {
    pub PreambleLength: u8,
    pub HeaderType: RadioLoRaPacketLengthsModes_t,
    pub PayloadLength: u8,
    pub CrcMode: RadioLoRaCrcModes_t,
    pub InvertIQ: RadioLoRaIQModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).PreambleLength
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(PreambleLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).HeaderType
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(HeaderType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).PayloadLength
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(PayloadLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).CrcMode
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(CrcMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).InvertIQ
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(InvertIQ)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_3 {
    pub PreambleLength: RadioPreambleLengths_t,
    pub SyncWordLength: RadioFlrcSyncWordLengths_t,
    pub SyncWordMatch: RadioSyncWordRxMatchs_t,
    pub HeaderType: RadioPacketLengthModes_t,
    pub PayloadLength: u8,
    pub CrcLength: RadioCrcTypes_t,
    pub Whitening: RadioWhiteningModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).PreambleLength
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(PreambleLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).SyncWordLength
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(SyncWordLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).SyncWordMatch
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(SyncWordMatch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).HeaderType
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(HeaderType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).PayloadLength
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(PayloadLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).CrcLength
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(CrcLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).Whitening
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Whitening)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_4 {
    pub ConnectionState: RadioBleConnectionStates_t,
    pub CrcField: RadioBleCrcFields_t,
    pub BlePacketType: RadioBlePacketTypes_t,
    pub Whitening: RadioWhiteningModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>())).ConnectionState
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ConnectionState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>())).CrcField
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(CrcField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>())).BlePacketType
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(BlePacketType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>())).Whitening
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Whitening)
        )
    );
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1>(),
        92usize,
        concat!("Size of: ", stringify!(PacketParams_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PacketParams_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1>())).Gfsk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1),
            "::",
            stringify!(Gfsk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1>())).LoRa as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1),
            "::",
            stringify!(LoRa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1>())).Flrc as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1),
            "::",
            stringify!(Flrc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1>())).Ble as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1),
            "::",
            stringify!(Ble)
        )
    );
}
#[test]
fn bindgen_test_layout_PacketParams_t() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t>(),
        96usize,
        concat!("Size of: ", stringify!(PacketParams_t))
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t>(),
        4usize,
        concat!("Alignment of ", stringify!(PacketParams_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PacketParams_t>())).PacketType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t),
            "::",
            stringify!(PacketType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PacketParams_t>())).Params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t),
            "::",
            stringify!(Params)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PacketStatus_t {
    pub packetType: RadioPacketTypes_t,
    pub Params: PacketStatus_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PacketStatus_t__bindgen_ty_1 {
    pub Gfsk: PacketStatus_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: PacketStatus_t__bindgen_ty_1__bindgen_ty_2,
    pub Flrc: PacketStatus_t__bindgen_ty_1__bindgen_ty_3,
    pub Ble: PacketStatus_t__bindgen_ty_1__bindgen_ty_4,
    _bindgen_union_align: [u8; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_1 {
    pub RssiAvg: i8,
    pub RssiSync: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncError: bool,
        LengthError: bool,
        CrcError: bool,
        AbortError: bool,
        HeaderReceived: bool,
        PacketReceived: bool,
        PacketControlerBusy: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncError: u8 = unsafe { ::core::mem::transmute(SyncError) };
            SyncError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LengthError: u8 = unsafe { ::core::mem::transmute(LengthError) };
            LengthError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CrcError: u8 = unsafe { ::core::mem::transmute(CrcError) };
            CrcError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AbortError: u8 = unsafe { ::core::mem::transmute(AbortError) };
            AbortError as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HeaderReceived: u8 = unsafe { ::core::mem::transmute(HeaderReceived) };
            HeaderReceived as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PacketReceived: u8 = unsafe { ::core::mem::transmute(PacketReceived) };
            PacketReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PacketControlerBusy: u8 = unsafe { ::core::mem::transmute(PacketControlerBusy) };
            PacketControlerBusy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn RxNoAck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RxNoAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketSent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RxNoAck: bool,
        PacketSent: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RxNoAck: u8 = unsafe { ::core::mem::transmute(RxNoAck) };
            RxNoAck as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PacketSent: u8 = unsafe { ::core::mem::transmute(PacketSent) };
            PacketSent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>())).RssiAvg
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(RssiAvg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>())).RssiSync
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(RssiSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>())).ErrorStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ErrorStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>())).TxRxStatus
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(TxRxStatus)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SyncAddrStatus: u8 = unsafe { ::core::mem::transmute(SyncAddrStatus) };
            SyncAddrStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_2 {
    pub RssiPkt: i8,
    pub SnrPkt: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncError: bool,
        LengthError: bool,
        CrcError: bool,
        AbortError: bool,
        HeaderReceived: bool,
        PacketReceived: bool,
        PacketControlerBusy: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncError: u8 = unsafe { ::core::mem::transmute(SyncError) };
            SyncError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LengthError: u8 = unsafe { ::core::mem::transmute(LengthError) };
            LengthError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CrcError: u8 = unsafe { ::core::mem::transmute(CrcError) };
            CrcError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AbortError: u8 = unsafe { ::core::mem::transmute(AbortError) };
            AbortError as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HeaderReceived: u8 = unsafe { ::core::mem::transmute(HeaderReceived) };
            HeaderReceived as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PacketReceived: u8 = unsafe { ::core::mem::transmute(PacketReceived) };
            PacketReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PacketControlerBusy: u8 = unsafe { ::core::mem::transmute(PacketControlerBusy) };
            PacketControlerBusy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    #[inline]
    pub fn RxNoAck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RxNoAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketSent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RxNoAck: bool,
        PacketSent: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RxNoAck: u8 = unsafe { ::core::mem::transmute(RxNoAck) };
            RxNoAck as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PacketSent: u8 = unsafe { ::core::mem::transmute(PacketSent) };
            PacketSent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>())).RssiPkt
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(RssiPkt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>())).SnrPkt
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SnrPkt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>())).ErrorStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ErrorStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>())).TxRxStatus
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(TxRxStatus)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SyncAddrStatus: u8 = unsafe { ::core::mem::transmute(SyncAddrStatus) };
            SyncAddrStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_3 {
    pub RssiAvg: i8,
    pub RssiSync: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncError: bool,
        LengthError: bool,
        CrcError: bool,
        AbortError: bool,
        HeaderReceived: bool,
        PacketReceived: bool,
        PacketControlerBusy: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncError: u8 = unsafe { ::core::mem::transmute(SyncError) };
            SyncError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LengthError: u8 = unsafe { ::core::mem::transmute(LengthError) };
            LengthError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CrcError: u8 = unsafe { ::core::mem::transmute(CrcError) };
            CrcError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AbortError: u8 = unsafe { ::core::mem::transmute(AbortError) };
            AbortError as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HeaderReceived: u8 = unsafe { ::core::mem::transmute(HeaderReceived) };
            HeaderReceived as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PacketReceived: u8 = unsafe { ::core::mem::transmute(PacketReceived) };
            PacketReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PacketControlerBusy: u8 = unsafe { ::core::mem::transmute(PacketControlerBusy) };
            PacketControlerBusy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    #[inline]
    pub fn RxPid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_RxPid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RxNoAck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RxNoAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RxPidErr(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RxPidErr(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketSent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RxPid: u8,
        RxNoAck: bool,
        RxPidErr: bool,
        PacketSent: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let RxPid: u8 = unsafe { ::core::mem::transmute(RxPid) };
            RxPid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RxNoAck: u8 = unsafe { ::core::mem::transmute(RxNoAck) };
            RxNoAck as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RxPidErr: u8 = unsafe { ::core::mem::transmute(RxPidErr) };
            RxPidErr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PacketSent: u8 = unsafe { ::core::mem::transmute(PacketSent) };
            PacketSent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>())).RssiAvg
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(RssiAvg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>())).RssiSync
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(RssiSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>())).ErrorStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ErrorStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>())).TxRxStatus
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(TxRxStatus)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SyncAddrStatus: u8 = unsafe { ::core::mem::transmute(SyncAddrStatus) };
            SyncAddrStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_4 {
    pub RssiAvg: i8,
    pub RssiSync: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncError: bool,
        LengthError: bool,
        CrcError: bool,
        AbortError: bool,
        HeaderReceived: bool,
        PacketReceived: bool,
        PacketControlerBusy: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncError: u8 = unsafe { ::core::mem::transmute(SyncError) };
            SyncError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LengthError: u8 = unsafe { ::core::mem::transmute(LengthError) };
            LengthError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CrcError: u8 = unsafe { ::core::mem::transmute(CrcError) };
            CrcError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AbortError: u8 = unsafe { ::core::mem::transmute(AbortError) };
            AbortError as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HeaderReceived: u8 = unsafe { ::core::mem::transmute(HeaderReceived) };
            HeaderReceived as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PacketReceived: u8 = unsafe { ::core::mem::transmute(PacketReceived) };
            PacketReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PacketControlerBusy: u8 = unsafe { ::core::mem::transmute(PacketControlerBusy) };
            PacketControlerBusy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    #[inline]
    pub fn PacketSent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PacketSent: bool) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PacketSent: u8 = unsafe { ::core::mem::transmute(PacketSent) };
            PacketSent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>())).RssiAvg
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(RssiAvg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>())).RssiSync
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(RssiSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>())).ErrorStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ErrorStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>())).TxRxStatus
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(TxRxStatus)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_4 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SyncAddrStatus: u8 = unsafe { ::core::mem::transmute(SyncAddrStatus) };
            SyncAddrStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1>(),
        5usize,
        concat!("Size of: ", stringify!(PacketStatus_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PacketStatus_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1>())).Gfsk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1),
            "::",
            stringify!(Gfsk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1>())).LoRa as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1),
            "::",
            stringify!(LoRa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1>())).Flrc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1),
            "::",
            stringify!(Flrc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1>())).Ble as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1),
            "::",
            stringify!(Ble)
        )
    );
}
#[test]
fn bindgen_test_layout_PacketStatus_t() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t>(),
        12usize,
        concat!("Size of: ", stringify!(PacketStatus_t))
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(PacketStatus_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PacketStatus_t>())).packetType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t),
            "::",
            stringify!(packetType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PacketStatus_t>())).Params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t),
            "::",
            stringify!(Params)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RxCounter_t {
    pub packetType: RadioPacketTypes_t,
    pub Params: RxCounter_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RxCounter_t__bindgen_ty_1 {
    pub Gfsk: RxCounter_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: RxCounter_t__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u16; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RxCounter_t__bindgen_ty_1__bindgen_ty_1 {
    pub PacketReceived: u16,
    pub CrcError: u16,
    pub LengthError: u16,
    pub SyncwordError: u16,
}
#[test]
fn bindgen_test_layout_RxCounter_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>())).PacketReceived
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(PacketReceived)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>())).CrcError
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(CrcError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>())).LengthError
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LengthError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>())).SyncwordError
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SyncwordError)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RxCounter_t__bindgen_ty_1__bindgen_ty_2 {
    pub PacketReceived: u16,
    pub CrcError: u16,
    pub HeaderValid: u16,
}
#[test]
fn bindgen_test_layout_RxCounter_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>())).PacketReceived
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(PacketReceived)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>())).CrcError
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(CrcError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>())).HeaderValid
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(HeaderValid)
        )
    );
}
#[test]
fn bindgen_test_layout_RxCounter_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RxCounter_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(RxCounter_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RxCounter_t__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(RxCounter_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1>())).Gfsk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1),
            "::",
            stringify!(Gfsk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1>())).LoRa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1),
            "::",
            stringify!(LoRa)
        )
    );
}
#[test]
fn bindgen_test_layout_RxCounter_t() {
    assert_eq!(
        ::core::mem::size_of::<RxCounter_t>(),
        12usize,
        concat!("Size of: ", stringify!(RxCounter_t))
    );
    assert_eq!(
        ::core::mem::align_of::<RxCounter_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RxCounter_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RxCounter_t>())).packetType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t),
            "::",
            stringify!(packetType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RxCounter_t>())).Params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t),
            "::",
            stringify!(Params)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CalibrationParams_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_CalibrationParams_t() {
    assert_eq!(
        ::core::mem::size_of::<CalibrationParams_t>(),
        1usize,
        concat!("Size of: ", stringify!(CalibrationParams_t))
    );
    assert_eq!(
        ::core::mem::align_of::<CalibrationParams_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CalibrationParams_t))
    );
}
impl CalibrationParams_t {
    #[inline]
    pub fn RC64KEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RC64KEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RC13MEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RC13MEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PLLEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PLLEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADCPulseEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ADCPulseEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADCBulkNEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ADCBulkNEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADCBulkPEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ADCBulkPEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RC64KEnable: u8,
        RC13MEnable: u8,
        PLLEnable: u8,
        ADCPulseEnable: u8,
        ADCBulkNEnable: u8,
        ADCBulkPEnable: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RC64KEnable: u8 = unsafe { ::core::mem::transmute(RC64KEnable) };
            RC64KEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RC13MEnable: u8 = unsafe { ::core::mem::transmute(RC13MEnable) };
            RC13MEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PLLEnable: u8 = unsafe { ::core::mem::transmute(PLLEnable) };
            PLLEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ADCPulseEnable: u8 = unsafe { ::core::mem::transmute(ADCPulseEnable) };
            ADCPulseEnable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ADCBulkNEnable: u8 = unsafe { ::core::mem::transmute(ADCBulkNEnable) };
            ADCBulkNEnable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ADCBulkPEnable: u8 = unsafe { ::core::mem::transmute(ADCBulkPEnable) };
            ADCBulkPEnable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SleepParams_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SleepParams_t() {
    assert_eq!(
        ::core::mem::size_of::<SleepParams_t>(),
        1usize,
        concat!("Size of: ", stringify!(SleepParams_t))
    );
    assert_eq!(
        ::core::mem::align_of::<SleepParams_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SleepParams_t))
    );
}
impl SleepParams_t {
    #[inline]
    pub fn WakeUpRTC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WakeUpRTC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InstructionRamRetention(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_InstructionRamRetention(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DataBufferRetention(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DataBufferRetention(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DataRamRetention(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DataRamRetention(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WakeUpRTC: u8,
        InstructionRamRetention: u8,
        DataBufferRetention: u8,
        DataRamRetention: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WakeUpRTC: u8 = unsafe { ::core::mem::transmute(WakeUpRTC) };
            WakeUpRTC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InstructionRamRetention: u8 =
                unsafe { ::core::mem::transmute(InstructionRamRetention) };
            InstructionRamRetention as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DataBufferRetention: u8 = unsafe { ::core::mem::transmute(DataBufferRetention) };
            DataBufferRetention as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DataRamRetention: u8 = unsafe { ::core::mem::transmute(DataRamRetention) };
            DataRamRetention as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    pub fn SX1280GetLoRaBandwidth(sx1280: *mut SX1280_t) -> i32;
}
extern "C" {
    pub fn SX1280GetRangingCorrectionPerSfBwGain(
        sx1280: *mut SX1280_t,
        sf: RadioLoRaSpreadingFactors_t,
        bw: RadioLoRaBandwidths_t,
        gain: i8,
    ) -> f64;
}
extern "C" {
    pub fn SX1280ComputeRangingCorrectionPolynome(
        sf: RadioLoRaSpreadingFactors_t,
        bw: RadioLoRaBandwidths_t,
        median: f64,
    ) -> f64;
}
extern "C" {
    pub fn SX1280OnDioIrq(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetRangingRole(sx1280: *mut SX1280_t, role: RadioRangingRoles_t);
}
extern "C" {
    pub fn SX1280Init(sx1280: *mut SX1280_t, callbacks: *mut RadioCallbacks_t);
}
extern "C" {
    pub fn SX1280SetPollingMode(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetInterruptMode(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetRegistersDefault(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280GetFirmwareVersion(sx1280: *mut SX1280_t) -> u16;
}
extern "C" {
    pub fn SX1280GetOpMode(sx1280: *mut SX1280_t) -> RadioOperatingModes_t;
}
extern "C" {
    pub fn SX1280GetStatus(sx1280: *mut SX1280_t) -> RadioStatus_t;
}
extern "C" {
    pub fn SX1280SetSleep(sx1280: *mut SX1280_t, sleepConfig: SleepParams_t);
}
extern "C" {
    pub fn SX1280SetStandby(sx1280: *mut SX1280_t, mode: RadioStandbyModes_t);
}
extern "C" {
    pub fn SX1280SetFs(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetTx(sx1280: *mut SX1280_t, timeout: TickTime_t);
}
extern "C" {
    pub fn SX1280SetRx(sx1280: *mut SX1280_t, timeout: TickTime_t);
}
extern "C" {
    pub fn SX1280SetRxDutyCycle(
        sx1280: *mut SX1280_t,
        Step: RadioTickSizes_t,
        NbStepRx: u16,
        RxNbStepSleep: u16,
    );
}
extern "C" {
    pub fn SX1280SetCad(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetTxContinuousWave(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetTxContinuousPreamble(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetPacketType(sx1280: *mut SX1280_t, packetType: RadioPacketTypes_t);
}
extern "C" {
    pub fn SX1280GetPacketType(sx1280: *mut SX1280_t) -> RadioPacketTypes_t;
}
extern "C" {
    pub fn SX1280SetRfFrequency(sx1280: *mut SX1280_t, frequency: u32);
}
extern "C" {
    pub fn SX1280SetTxParams(sx1280: *mut SX1280_t, power: i8, rampTime: RadioRampTimes_t);
}
extern "C" {
    pub fn SX1280SetCadParams(sx1280: *mut SX1280_t, cadSymbolNum: RadioLoRaCadSymbols_t);
}
extern "C" {
    pub fn SX1280SetBufferBaseAddresses(
        sx1280: *mut SX1280_t,
        txBaseAddress: u8,
        rxBaseAddress: u8,
    );
}
extern "C" {
    pub fn SX1280SetModulationParams(sx1280: *mut SX1280_t, modParams: *mut ModulationParams_t);
}
extern "C" {
    pub fn SX1280SetPacketParams(sx1280: *mut SX1280_t, packetParams: *mut PacketParams_t);
}
extern "C" {
    pub fn SX1280GetRxBufferStatus(
        sx1280: *mut SX1280_t,
        payloadLength: *mut u8,
        rxStartBuffer: *mut u8,
    );
}
extern "C" {
    pub fn SX1280GetPacketStatus(sx1280: *mut SX1280_t, pktStatus: *mut PacketStatus_t);
}
extern "C" {
    pub fn SX1280GetRssiInst(sx1280: *mut SX1280_t) -> i8;
}
extern "C" {
    pub fn SX1280SetDioIrqParams(
        sx1280: *mut SX1280_t,
        irqMask: u16,
        dio1Mask: u16,
        dio2Mask: u16,
        dio3Mask: u16,
    );
}
extern "C" {
    pub fn SX1280GetIrqStatus(sx1280: *mut SX1280_t) -> u16;
}
extern "C" {
    pub fn SX1280ClearIrqStatus(sx1280: *mut SX1280_t, irq: u16);
}
extern "C" {
    pub fn SX1280Calibrate(sx1280: *mut SX1280_t, calibParam: CalibrationParams_t);
}
extern "C" {
    pub fn SX1280SetRegulatorMode(sx1280: *mut SX1280_t, mode: RadioRegulatorModes_t);
}
extern "C" {
    pub fn SX1280SetSaveContext(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetAutoTx(sx1280: *mut SX1280_t, time: u16);
}
extern "C" {
    pub fn SX1280StopAutoTx(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetAutoFS(sx1280: *mut SX1280_t, enable: u8);
}
extern "C" {
    pub fn SX1280SetLongPreamble(sx1280: *mut SX1280_t, enable: u8);
}
extern "C" {
    pub fn SX1280SetPayload(sx1280: *mut SX1280_t, payload: *mut u8, size: u8);
}
extern "C" {
    pub fn SX1280GetPayload(
        sx1280: *mut SX1280_t,
        payload: *mut u8,
        size: *mut u8,
        maxSize: u8,
    ) -> u8;
}
extern "C" {
    pub fn SX1280SendPayload(
        sx1280: *mut SX1280_t,
        payload: *mut u8,
        size: u8,
        timeout: TickTime_t,
    );
}
extern "C" {
    pub fn SX1280SetSyncWord(sx1280: *mut SX1280_t, syncWordIdx: u8, syncWord: *mut u8) -> u8;
}
extern "C" {
    pub fn SX1280SetSyncWordErrorTolerance(sx1280: *mut SX1280_t, errorBits: u8);
}
extern "C" {
    pub fn SX1280SetCrcSeed(sx1280: *mut SX1280_t, seed: u16);
}
extern "C" {
    pub fn SX1280SetBleAccessAddress(sx1280: *mut SX1280_t, accessAddress: u32);
}
extern "C" {
    pub fn SX1280SetBleAdvertizerAccessAddress(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetCrcPolynomial(sx1280: *mut SX1280_t, seed: u16);
}
extern "C" {
    pub fn SX1280SetWhiteningSeed(sx1280: *mut SX1280_t, seed: u8);
}
extern "C" {
    pub fn SX1280EnableManualGain(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280DisableManualGain(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280SetManualGainValue(sx1280: *mut SX1280_t, gain: u8);
}
extern "C" {
    pub fn SX1280SetLNAGainSetting(sx1280: *mut SX1280_t, lnaSetting: RadioLnaSettings_t);
}
extern "C" {
    pub fn SX1280SetRangingIdLength(sx1280: *mut SX1280_t, length: RadioRangingIdCheckLengths_t);
}
extern "C" {
    pub fn SX1280SetDeviceRangingAddress(sx1280: *mut SX1280_t, address: u32);
}
extern "C" {
    pub fn SX1280SetRangingRequestAddress(sx1280: *mut SX1280_t, address: u32);
}
extern "C" {
    pub fn SX1280GetRangingResult(
        sx1280: *mut SX1280_t,
        resultType: RadioRangingResultTypes_t,
    ) -> f64;
}
extern "C" {
    pub fn SX1280SetRangingCalibration(sx1280: *mut SX1280_t, cal: u16);
}
extern "C" {
    pub fn SX1280GetRangingPowerDeltaThresholdIndicator(sx1280: *mut SX1280_t) -> u8;
}
extern "C" {
    pub fn SX1280RangingClearFilterResult(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280RangingSetFilterNumSamples(sx1280: *mut SX1280_t, numSample: u8);
}
extern "C" {
    pub fn SX1280GetFrequencyError(sx1280: *mut SX1280_t) -> f64;
}
extern "C" {
    pub fn SX1280ProcessIrqs(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280ClearInstructionRam(sx1280: *mut SX1280_t);
}
extern "C" {
    pub fn SX1280ParseHexFileLine(sx1280: *mut SX1280_t, line: *mut libc::c_char) -> i8;
}
extern "C" {
    pub fn SX1280GetHexFileLineFields(
        sx1280: *mut SX1280_t,
        line: *mut libc::c_char,
        bytes: *mut u8,
        addr: *mut u16,
        num: *mut u16,
        code: *mut u8,
    ) -> i8;
}
