#![allow(non_snake_case)]
use libc;

/* automatically generated by rust-bindgen */

#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
impl <T> __BindgenUnionField<T> {
    #[inline]
    pub fn new() -> Self { __BindgenUnionField(::core::marker::PhantomData) }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T { ::core::mem::transmute(self) }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T { ::core::mem::transmute(self) }
}
impl <T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self { Self::new() }
}
impl <T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self { Self::new() }
}
impl <T> ::core::marker::Copy for __BindgenUnionField<T> { }
impl <T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
pub const __WORDSIZE: libc::c_uint = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: libc::c_uint = 0;
pub const __DARWIN_ONLY_VERS_1050: libc::c_uint = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: libc::c_uint = 1;
pub const __DARWIN_UNIX03: libc::c_uint = 1;
pub const __DARWIN_64_BIT_INO_T: libc::c_uint = 1;
pub const __DARWIN_VERS_1050: libc::c_uint = 1;
pub const __DARWIN_NON_CANCELABLE: libc::c_uint = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\x00";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\x00";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\x00";
pub const __DARWIN_C_ANSI: libc::c_uint = 4096;
pub const __DARWIN_C_FULL: libc::c_uint = 900000;
pub const __DARWIN_C_LEVEL: libc::c_uint = 900000;
pub const __STDC_WANT_LIB_EXT1__: libc::c_uint = 1;
pub const __DARWIN_NO_LONG_LONG: libc::c_uint = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: libc::c_uint = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: libc::c_uint = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: libc::c_uint = 3;
pub const __PTHREAD_SIZE__: libc::c_uint = 8176;
pub const __PTHREAD_ATTR_SIZE__: libc::c_uint = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: libc::c_uint = 8;
pub const __PTHREAD_MUTEX_SIZE__: libc::c_uint = 56;
pub const __PTHREAD_CONDATTR_SIZE__: libc::c_uint = 8;
pub const __PTHREAD_COND_SIZE__: libc::c_uint = 40;
pub const __PTHREAD_ONCE_SIZE__: libc::c_uint = 8;
pub const __PTHREAD_RWLOCK_SIZE__: libc::c_uint = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: libc::c_uint = 16;
pub const INT8_MAX: libc::c_uint = 127;
pub const INT16_MAX: libc::c_uint = 32767;
pub const INT32_MAX: libc::c_uint = 2147483647;
pub const INT64_MAX: libc::c_ulonglong = 9223372036854775807;
pub const INT8_MIN: libc::c_int = -128;
pub const INT16_MIN: libc::c_int = -32768;
pub const INT32_MIN: libc::c_int = -2147483648;
pub const INT64_MIN: libc::c_longlong = -9223372036854775808;
pub const UINT8_MAX: libc::c_uint = 255;
pub const UINT16_MAX: libc::c_uint = 65535;
pub const UINT32_MAX: libc::c_uint = 4294967295;
pub const UINT64_MAX: libc::c_int = -1;
pub const INT_LEAST8_MIN: libc::c_int = -128;
pub const INT_LEAST16_MIN: libc::c_int = -32768;
pub const INT_LEAST32_MIN: libc::c_int = -2147483648;
pub const INT_LEAST64_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_LEAST8_MAX: libc::c_uint = 127;
pub const INT_LEAST16_MAX: libc::c_uint = 32767;
pub const INT_LEAST32_MAX: libc::c_uint = 2147483647;
pub const INT_LEAST64_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINT_LEAST8_MAX: libc::c_uint = 255;
pub const UINT_LEAST16_MAX: libc::c_uint = 65535;
pub const UINT_LEAST32_MAX: libc::c_uint = 4294967295;
pub const UINT_LEAST64_MAX: libc::c_int = -1;
pub const INT_FAST8_MIN: libc::c_int = -128;
pub const INT_FAST16_MIN: libc::c_int = -32768;
pub const INT_FAST32_MIN: libc::c_int = -2147483648;
pub const INT_FAST64_MIN: libc::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: libc::c_uint = 127;
pub const INT_FAST16_MAX: libc::c_uint = 32767;
pub const INT_FAST32_MAX: libc::c_uint = 2147483647;
pub const INT_FAST64_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: libc::c_uint = 255;
pub const UINT_FAST16_MAX: libc::c_uint = 65535;
pub const UINT_FAST32_MAX: libc::c_uint = 4294967295;
pub const UINT_FAST64_MAX: libc::c_int = -1;
pub const INTPTR_MAX: libc::c_ulonglong = 9223372036854775807;
pub const INTPTR_MIN: libc::c_longlong = -9223372036854775808;
pub const UINTPTR_MAX: libc::c_int = -1;
pub const INTMAX_MIN: libc::c_longlong = -9223372036854775808;
pub const INTMAX_MAX: libc::c_ulonglong = 9223372036854775807;
pub const UINTMAX_MAX: libc::c_int = -1;
pub const PTRDIFF_MIN: libc::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: libc::c_ulonglong = 9223372036854775807;
pub const SIZE_MAX: libc::c_int = -1;
pub const RSIZE_MAX: libc::c_int = -1;
pub const WINT_MIN: libc::c_int = -2147483648;
pub const WINT_MAX: libc::c_uint = 2147483647;
pub const SIG_ATOMIC_MIN: libc::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: libc::c_uint = 2147483647;
pub const true_: libc::c_uint = 1;
pub const false_: libc::c_uint = 0;
pub const __bool_true_false_are_defined: libc::c_uint = 1;
pub const __API_TO_BE_DEPRECATED: libc::c_uint = 100000;
pub const __MAC_10_0: libc::c_uint = 1000;
pub const __MAC_10_1: libc::c_uint = 1010;
pub const __MAC_10_2: libc::c_uint = 1020;
pub const __MAC_10_3: libc::c_uint = 1030;
pub const __MAC_10_4: libc::c_uint = 1040;
pub const __MAC_10_5: libc::c_uint = 1050;
pub const __MAC_10_6: libc::c_uint = 1060;
pub const __MAC_10_7: libc::c_uint = 1070;
pub const __MAC_10_8: libc::c_uint = 1080;
pub const __MAC_10_9: libc::c_uint = 1090;
pub const __MAC_10_10: libc::c_uint = 101000;
pub const __MAC_10_10_2: libc::c_uint = 101002;
pub const __MAC_10_10_3: libc::c_uint = 101003;
pub const __MAC_10_11: libc::c_uint = 101100;
pub const __MAC_10_11_2: libc::c_uint = 101102;
pub const __MAC_10_11_3: libc::c_uint = 101103;
pub const __MAC_10_11_4: libc::c_uint = 101104;
pub const __MAC_10_12: libc::c_uint = 101200;
pub const __MAC_10_12_1: libc::c_uint = 101201;
pub const __MAC_10_12_2: libc::c_uint = 101202;
pub const __MAC_10_12_4: libc::c_uint = 101204;
pub const __MAC_10_13: libc::c_uint = 101300;
pub const __MAC_10_13_1: libc::c_uint = 101301;
pub const __MAC_10_13_2: libc::c_uint = 101302;
pub const __MAC_10_13_4: libc::c_uint = 101304;
pub const __MAC_10_14: libc::c_uint = 101400;
pub const __MAC_10_14_1: libc::c_uint = 101401;
pub const __IPHONE_2_0: libc::c_uint = 20000;
pub const __IPHONE_2_1: libc::c_uint = 20100;
pub const __IPHONE_2_2: libc::c_uint = 20200;
pub const __IPHONE_3_0: libc::c_uint = 30000;
pub const __IPHONE_3_1: libc::c_uint = 30100;
pub const __IPHONE_3_2: libc::c_uint = 30200;
pub const __IPHONE_4_0: libc::c_uint = 40000;
pub const __IPHONE_4_1: libc::c_uint = 40100;
pub const __IPHONE_4_2: libc::c_uint = 40200;
pub const __IPHONE_4_3: libc::c_uint = 40300;
pub const __IPHONE_5_0: libc::c_uint = 50000;
pub const __IPHONE_5_1: libc::c_uint = 50100;
pub const __IPHONE_6_0: libc::c_uint = 60000;
pub const __IPHONE_6_1: libc::c_uint = 60100;
pub const __IPHONE_7_0: libc::c_uint = 70000;
pub const __IPHONE_7_1: libc::c_uint = 70100;
pub const __IPHONE_8_0: libc::c_uint = 80000;
pub const __IPHONE_8_1: libc::c_uint = 80100;
pub const __IPHONE_8_2: libc::c_uint = 80200;
pub const __IPHONE_8_3: libc::c_uint = 80300;
pub const __IPHONE_8_4: libc::c_uint = 80400;
pub const __IPHONE_9_0: libc::c_uint = 90000;
pub const __IPHONE_9_1: libc::c_uint = 90100;
pub const __IPHONE_9_2: libc::c_uint = 90200;
pub const __IPHONE_9_3: libc::c_uint = 90300;
pub const __IPHONE_10_0: libc::c_uint = 100000;
pub const __IPHONE_10_1: libc::c_uint = 100100;
pub const __IPHONE_10_2: libc::c_uint = 100200;
pub const __IPHONE_10_3: libc::c_uint = 100300;
pub const __IPHONE_11_0: libc::c_uint = 110000;
pub const __IPHONE_11_1: libc::c_uint = 110100;
pub const __IPHONE_11_2: libc::c_uint = 110200;
pub const __IPHONE_11_3: libc::c_uint = 110300;
pub const __IPHONE_11_4: libc::c_uint = 110400;
pub const __IPHONE_12_0: libc::c_uint = 120000;
pub const __IPHONE_12_1: libc::c_uint = 120100;
pub const __TVOS_9_0: libc::c_uint = 90000;
pub const __TVOS_9_1: libc::c_uint = 90100;
pub const __TVOS_9_2: libc::c_uint = 90200;
pub const __TVOS_10_0: libc::c_uint = 100000;
pub const __TVOS_10_0_1: libc::c_uint = 100001;
pub const __TVOS_10_1: libc::c_uint = 100100;
pub const __TVOS_10_2: libc::c_uint = 100200;
pub const __TVOS_11_0: libc::c_uint = 110000;
pub const __TVOS_11_1: libc::c_uint = 110100;
pub const __TVOS_11_2: libc::c_uint = 110200;
pub const __TVOS_11_3: libc::c_uint = 110300;
pub const __TVOS_11_4: libc::c_uint = 110400;
pub const __TVOS_12_0: libc::c_uint = 120000;
pub const __TVOS_12_1: libc::c_uint = 120100;
pub const __WATCHOS_1_0: libc::c_uint = 10000;
pub const __WATCHOS_2_0: libc::c_uint = 20000;
pub const __WATCHOS_2_1: libc::c_uint = 20100;
pub const __WATCHOS_2_2: libc::c_uint = 20200;
pub const __WATCHOS_3_0: libc::c_uint = 30000;
pub const __WATCHOS_3_1: libc::c_uint = 30100;
pub const __WATCHOS_3_1_1: libc::c_uint = 30101;
pub const __WATCHOS_3_2: libc::c_uint = 30200;
pub const __WATCHOS_4_0: libc::c_uint = 40000;
pub const __WATCHOS_4_1: libc::c_uint = 40100;
pub const __WATCHOS_4_2: libc::c_uint = 40200;
pub const __WATCHOS_4_3: libc::c_uint = 40300;
pub const __WATCHOS_5_0: libc::c_uint = 50000;
pub const __WATCHOS_5_1: libc::c_uint = 50100;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: libc::c_uint = 101401;
pub const FP_NAN: libc::c_uint = 1;
pub const FP_INFINITE: libc::c_uint = 2;
pub const FP_ZERO: libc::c_uint = 3;
pub const FP_NORMAL: libc::c_uint = 4;
pub const FP_SUBNORMAL: libc::c_uint = 5;
pub const FP_SUPERNORMAL: libc::c_uint = 6;
pub const FP_ILOGB0: libc::c_int = -2147483648;
pub const FP_ILOGBNAN: libc::c_int = -2147483648;
pub const MATH_ERRNO: libc::c_uint = 1;
pub const MATH_ERREXCEPT: libc::c_uint = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const FP_SNAN: libc::c_uint = 1;
pub const FP_QNAN: libc::c_uint = 1;
pub const DOMAIN: libc::c_uint = 1;
pub const SING: libc::c_uint = 2;
pub const OVERFLOW: libc::c_uint = 3;
pub const UNDERFLOW: libc::c_uint = 4;
pub const TLOSS: libc::c_uint = 5;
pub const PLOSS: libc::c_uint = 6;
pub const SX1280_DEBUG: libc::c_uint = 0;
pub const XTAL_FREQ: libc::c_uint = 52000000;
pub const AUTO_RX_TX_OFFSET: libc::c_uint = 33;
pub const REG_LR_FIRMWARE_VERSION_MSB: libc::c_uint = 339;
pub const REG_LR_CRCSEEDBASEADDR: libc::c_uint = 2504;
pub const REG_LR_CRCPOLYBASEADDR: libc::c_uint = 2502;
pub const REG_LR_WHITSEEDBASEADDR: libc::c_uint = 2501;
pub const REG_LR_RANGINGIDCHECKLENGTH: libc::c_uint = 2353;
pub const REG_LR_DEVICERANGINGADDR: libc::c_uint = 2326;
pub const REG_LR_REQUESTRANGINGADDR: libc::c_uint = 2322;
pub const REG_LR_RANGINGRESULTCONFIG: libc::c_uint = 2340;
pub const MASK_RANGINGMUXSEL: libc::c_uint = 207;
pub const REG_LR_RANGINGRESULTBASEADDR: libc::c_uint = 2401;
pub const REG_LR_RANGINGRESULTSFREEZE: libc::c_uint = 2431;
pub const REG_LR_RANGINGRERXTXDELAYCAL: libc::c_uint = 2348;
pub const REG_LR_RANGINGFILTERWINDOWSIZE: libc::c_uint = 2334;
pub const REG_LR_RANGINGRESULTCLEARREG: libc::c_uint = 2339;
pub const REG_RANGING_RSSI: libc::c_uint = 2404;
pub const DEFAULT_RANGING_FILTER_SIZE: libc::c_uint = 127;
pub const REG_LR_PACKETPARAMS: libc::c_uint = 2307;
pub const REG_LR_PAYLOADLENGTH: libc::c_uint = 2305;
pub const IRAM_START_ADDRESS: libc::c_uint = 32768;
pub const IRAM_SIZE: libc::c_uint = 16384;
pub const REG_LR_SYNCWORDBASEADDRESS1: libc::c_uint = 2510;
pub const REG_LR_SYNCWORDBASEADDRESS2: libc::c_uint = 2515;
pub const REG_LR_SYNCWORDBASEADDRESS3: libc::c_uint = 2520;
pub const REG_LR_ESTIMATED_FREQUENCY_ERROR_MSB: libc::c_uint = 2388;
pub const REG_LR_ESTIMATED_FREQUENCY_ERROR_MASK: libc::c_uint = 1048575;
pub const REG_LR_SYNCWORDTOLERANCE: libc::c_uint = 2509;
pub const REG_LR_BLE_ACCESS_ADDRESS: libc::c_uint = 2511;
pub const BLE_ADVERTIZER_ACCESS_ADDRESS: libc::c_uint = 2391391958;
pub const REG_LNA_REGIME: libc::c_uint = 2193;
pub const MASK_LNA_REGIME: libc::c_uint = 192;
pub const REG_ENABLE_MANUAL_GAIN_CONTROL: libc::c_uint = 2207;
pub const MASK_MANUAL_GAIN_CONTROL: libc::c_uint = 128;
pub const REG_DEMOD_DETECTION: libc::c_uint = 2197;
pub const MASK_DEMOD_DETECTION: libc::c_uint = 254;
pub const REG_MANUAL_GAIN_VALUE: libc::c_uint = 2206;
pub const MASK_MANUAL_GAIN_VALUE: libc::c_uint = 240;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub type __darwin_intptr_t = libc::c_long;
pub type __darwin_natural_t = libc::c_uint;
pub type __darwin_ct_rune_t = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __mbstate_t {
    pub __mbstate8: __BindgenUnionField<[libc::c_char; 128usize]>,
    pub _mbstateL: __BindgenUnionField<libc::c_longlong>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(::core::mem::size_of::<__mbstate_t>() , 128usize , concat ! (
               "Size of: " , stringify ! ( __mbstate_t ) ));
    assert_eq! (::core::mem::align_of::<__mbstate_t>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __mbstate_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . __mbstate8 as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( __mbstate8 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __mbstate_t ) ) . _mbstateL as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __mbstate_t ) , "::" ,
                stringify ! ( _mbstateL ) ));
}
impl Clone for __mbstate_t {
    fn clone(&self) -> Self { *self }
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = libc::c_long;
pub type __darwin_size_t = libc::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = libc::c_int;
pub type __darwin_clock_t = libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = libc::c_long;
pub type __darwin_time_t = libc::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = libc::c_uint;
pub type __darwin_fsfilcnt_t = libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [libc::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [libc::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                   *mut libc::c_void)>,
    pub __arg: *mut libc::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(::core::mem::size_of::<__darwin_pthread_handler_rec>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( __darwin_pthread_handler_rec ) ));
    assert_eq! (::core::mem::align_of::<__darwin_pthread_handler_rec>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( __darwin_pthread_handler_rec )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) .
                __routine as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! (
                __routine ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __arg
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __arg )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __darwin_pthread_handler_rec ) ) . __next
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                __darwin_pthread_handler_rec ) , "::" , stringify ! ( __next )
                ));
}
impl Clone for __darwin_pthread_handler_rec {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_attr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(::core::mem::size_of::<_opaque_pthread_attr_t>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_attr_t )
               ));
    assert_eq! (::core::mem::align_of::<_opaque_pthread_attr_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_attr_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_attr_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_attr_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
pub struct _opaque_pthread_cond_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(::core::mem::size_of::<_opaque_pthread_cond_t>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_cond_t )
               ));
    assert_eq! (::core::mem::align_of::<_opaque_pthread_cond_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_cond_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_cond_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_cond_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(::core::mem::size_of::<_opaque_pthread_condattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_condattr_t ) ));
    assert_eq! (::core::mem::align_of::<_opaque_pthread_condattr_t>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_condattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __sig as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_condattr_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_condattr_t ) , "::" , stringify ! ( __opaque )
                ));
}
impl Clone for _opaque_pthread_condattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(::core::mem::size_of::<_opaque_pthread_mutex_t>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (::core::mem::align_of::<_opaque_pthread_mutex_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutex_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutex_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_mutex_t
                ) , "::" , stringify ! ( __opaque ) ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(::core::mem::size_of::<_opaque_pthread_mutexattr_t>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_mutexattr_t ) ));
    assert_eq! (::core::mem::align_of::<_opaque_pthread_mutexattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_mutexattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_mutexattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_mutexattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_mutexattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_once_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(::core::mem::size_of::<_opaque_pthread_once_t>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_once_t )
               ));
    assert_eq! (::core::mem::align_of::<_opaque_pthread_once_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_once_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_once_t ) ) . __opaque as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_once_t
                ) , "::" , stringify ! ( __opaque ) ));
}
impl Clone for _opaque_pthread_once_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(::core::mem::size_of::<_opaque_pthread_rwlock_t>() , 200usize ,
               concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (::core::mem::align_of::<_opaque_pthread_rwlock_t>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlock_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __sig as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlock_t ) ) . __opaque
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlock_t ) , "::" , stringify ! ( __opaque )
                ));
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(::core::mem::size_of::<_opaque_pthread_rwlockattr_t>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( _opaque_pthread_rwlockattr_t ) ));
    assert_eq! (::core::mem::align_of::<_opaque_pthread_rwlockattr_t>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( _opaque_pthread_rwlockattr_t )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) . __sig
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __sig )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_rwlockattr_t ) ) .
                __opaque as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                _opaque_pthread_rwlockattr_t ) , "::" , stringify ! ( __opaque
                ) ));
}
impl Clone for _opaque_pthread_rwlockattr_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
pub struct _opaque_pthread_t {
    pub __sig: libc::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [libc::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(::core::mem::size_of::<_opaque_pthread_t>() , 8192usize ,
               concat ! ( "Size of: " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (::core::mem::align_of::<_opaque_pthread_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( _opaque_pthread_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __sig as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __sig ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __cleanup_stack
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __cleanup_stack ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const _opaque_pthread_t ) ) . __opaque as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( _opaque_pthread_t ) ,
                "::" , stringify ! ( __opaque ) ));
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = libc::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = libc::c_uchar;
pub type u_int16_t = libc::c_ushort;
pub type u_int32_t = libc::c_uint;
pub type u_int64_t = libc::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = libc::c_long;
pub type uintmax_t = libc::c_ulong;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    #[link_name = "_Z18__math_errhandling"]
    pub fn __math_errhandling() -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z13__fpclassifyf"]
    pub fn __fpclassifyf(arg1: f32) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z13__fpclassifyd"]
    pub fn __fpclassifyd(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z13__fpclassifyl"]
    pub fn __fpclassifyl(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z18__inline_isfinitef"]
    pub fn __inline_isfinitef(arg1: f32) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z18__inline_isfinited"]
    pub fn __inline_isfinited(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z18__inline_isfinitel"]
    pub fn __inline_isfinitel(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z15__inline_isinff"]
    pub fn __inline_isinff(arg1: f32) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z15__inline_isinfd"]
    pub fn __inline_isinfd(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z15__inline_isinfl"]
    pub fn __inline_isinfl(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z15__inline_isnanf"]
    pub fn __inline_isnanf(arg1: f32) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z15__inline_isnand"]
    pub fn __inline_isnand(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z15__inline_isnanl"]
    pub fn __inline_isnanl(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z18__inline_isnormalf"]
    pub fn __inline_isnormalf(arg1: f32) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z18__inline_isnormald"]
    pub fn __inline_isnormald(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z18__inline_isnormall"]
    pub fn __inline_isnormall(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z17__inline_signbitf"]
    pub fn __inline_signbitf(arg1: f32) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z17__inline_signbitd"]
    pub fn __inline_signbitd(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z17__inline_signbitl"]
    pub fn __inline_signbitl(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z5acosf"]
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4acos"]
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5acosl"]
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5asinf"]
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4asin"]
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5asinl"]
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5atanf"]
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4atan"]
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5atanl"]
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6atan2f"]
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5atan2"]
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6atan2l"]
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4cosf"]
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z3cos"]
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4cosl"]
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4sinf"]
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z3sin"]
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4sinl"]
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4tanf"]
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z3tan"]
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4tanl"]
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6acoshf"]
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5acosh"]
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6acoshl"]
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6asinhf"]
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5asinh"]
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6asinhl"]
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6atanhf"]
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5atanh"]
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6atanhl"]
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5coshf"]
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4cosh"]
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5coshl"]
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5sinhf"]
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4sinh"]
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5sinhl"]
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5tanhf"]
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4tanh"]
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5tanhl"]
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4expf"]
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z3exp"]
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4expl"]
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5exp2f"]
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4exp2"]
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5exp2l"]
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6expm1f"]
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5expm1"]
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6expm1l"]
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4logf"]
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z3log"]
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4logl"]
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6log10f"]
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5log10"]
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6log10l"]
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5log2f"]
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4log2"]
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5log2l"]
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6log1pf"]
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5log1p"]
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6log1pl"]
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5logbf"]
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4logb"]
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5logbl"]
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5modff"]
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4modf"]
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5modfl"]
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6ldexpf"]
    pub fn ldexpf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
    #[link_name = "_Z5ldexp"]
    pub fn ldexp(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "_Z6ldexpl"]
    pub fn ldexpl(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "_Z6frexpf"]
    pub fn frexpf(arg1: f32, arg2: *mut libc::c_int) -> f32;
}
extern "C" {
    #[link_name = "_Z5frexp"]
    pub fn frexp(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "_Z6frexpl"]
    pub fn frexpl(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "_Z6ilogbf"]
    pub fn ilogbf(arg1: f32) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z5ilogb"]
    pub fn ilogb(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z6ilogbl"]
    pub fn ilogbl(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z7scalbnf"]
    pub fn scalbnf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
    #[link_name = "_Z6scalbn"]
    pub fn scalbn(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "_Z7scalbnl"]
    pub fn scalbnl(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "_Z8scalblnf"]
    pub fn scalblnf(arg1: f32, arg2: libc::c_long) -> f32;
}
extern "C" {
    #[link_name = "_Z7scalbln"]
    pub fn scalbln(arg1: f64, arg2: libc::c_long) -> f64;
}
extern "C" {
    #[link_name = "_Z8scalblnl"]
    pub fn scalblnl(arg1: f64, arg2: libc::c_long) -> f64;
}
extern "C" {
    #[link_name = "_Z5fabsf"]
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4fabs"]
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5fabsl"]
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5cbrtf"]
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4cbrt"]
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5cbrtl"]
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6hypotf"]
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5hypot"]
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6hypotl"]
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4powf"]
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z3pow"]
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4powl"]
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5sqrtf"]
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4sqrt"]
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5sqrtl"]
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4erff"]
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z3erf"]
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4erfl"]
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5erfcf"]
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4erfc"]
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5erfcl"]
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z7lgammaf"]
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z6lgamma"]
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z7lgammal"]
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z7tgammaf"]
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z6tgamma"]
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z7tgammal"]
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5ceilf"]
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4ceil"]
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5ceill"]
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6floorf"]
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5floor"]
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6floorl"]
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z10nearbyintf"]
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z9nearbyint"]
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z10nearbyintl"]
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5rintf"]
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4rint"]
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5rintl"]
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6lrintf"]
    pub fn lrintf(arg1: f32) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z5lrint"]
    pub fn lrint(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z6lrintl"]
    pub fn lrintl(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z6roundf"]
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5round"]
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6roundl"]
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z7lroundf"]
    pub fn lroundf(arg1: f32) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z6lround"]
    pub fn lround(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z7lroundl"]
    pub fn lroundl(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z7llrintf"]
    pub fn llrintf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "_Z6llrint"]
    pub fn llrint(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "_Z7llrintl"]
    pub fn llrintl(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "_Z8llroundf"]
    pub fn llroundf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "_Z7llround"]
    pub fn llround(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "_Z8llroundl"]
    pub fn llroundl(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "_Z6truncf"]
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z5trunc"]
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6truncl"]
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5fmodf"]
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4fmod"]
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5fmodl"]
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z10remainderf"]
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z9remainder"]
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z10remainderl"]
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z7remquof"]
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut libc::c_int) -> f32;
}
extern "C" {
    #[link_name = "_Z6remquo"]
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "_Z7remquol"]
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "_Z9copysignf"]
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z8copysign"]
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z9copysignl"]
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4nanf"]
    pub fn nanf(arg1: *const libc::c_char) -> f32;
}
extern "C" {
    #[link_name = "_Z3nan"]
    pub fn nan(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    #[link_name = "_Z4nanl"]
    pub fn nanl(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    #[link_name = "_Z10nextafterf"]
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z9nextafter"]
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z10nextafterl"]
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z10nexttoward"]
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z11nexttowardf"]
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    #[link_name = "_Z11nexttowardl"]
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5fdimf"]
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4fdim"]
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5fdiml"]
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5fmaxf"]
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4fmax"]
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5fmaxl"]
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5fminf"]
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z4fmin"]
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5fminl"]
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4fmaf"]
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z3fma"]
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z4fmal"]
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6__inff"]
    pub fn __inff() -> f32;
}
extern "C" {
    #[link_name = "_Z5__inf"]
    pub fn __inf() -> f64;
}
extern "C" {
    #[link_name = "_Z6__infl"]
    pub fn __infl() -> f64;
}
extern "C" {
    #[link_name = "_Z5__nan"]
    pub fn __nan() -> f32;
}
extern "C" {
    #[link_name = "_Z8__exp10f"]
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z7__exp10"]
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z9__sincosf"]
    pub fn __sincosf(__x: f32, __sinp: *mut f32, __cosp: *mut f32);
}
extern "C" {
    #[link_name = "_Z8__sincos"]
    pub fn __sincos(__x: f64, __sinp: *mut f64, __cosp: *mut f64);
}
extern "C" {
    #[link_name = "_Z8__cospif"]
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z7__cospi"]
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z8__sinpif"]
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z7__sinpi"]
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z8__tanpif"]
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "_Z7__tanpi"]
    pub fn __tanpi(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z11__sincospif"]
    pub fn __sincospif(__x: f32, __sinp: *mut f32, __cosp: *mut f32);
}
extern "C" {
    #[link_name = "_Z10__sincospi"]
    pub fn __sincospi(__x: f64, __sinp: *mut f64, __cosp: *mut f64);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    assert_eq!(::core::mem::size_of::<__float2>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __float2 ) ));
    assert_eq! (::core::mem::align_of::<__float2>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __float2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __float2 ) ) . __sinval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __float2 ) , "::" ,
                stringify ! ( __sinval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __float2 ) ) . __cosval as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __float2 ) , "::" ,
                stringify ! ( __cosval ) ));
}
impl Clone for __float2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    assert_eq!(::core::mem::size_of::<__double2>() , 16usize , concat ! (
               "Size of: " , stringify ! ( __double2 ) ));
    assert_eq! (::core::mem::align_of::<__double2>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __double2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __double2 ) ) . __sinval as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __double2 ) , "::" ,
                stringify ! ( __sinval ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __double2 ) ) . __cosval as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __double2 ) , "::" ,
                stringify ! ( __cosval ) ));
}
impl Clone for __double2 {
    fn clone(&self) -> Self { *self }
}
extern "C" {
    #[link_name = "_Z15__sincosf_stret"]
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    #[link_name = "_Z14__sincos_stret"]
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    #[link_name = "_Z17__sincospif_stret"]
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    #[link_name = "_Z16__sincospi_stret"]
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    #[link_name = "_Z2j0"]
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z2j1"]
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z2jn"]
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z2y0"]
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z2y1"]
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z2yn"]
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z5scalb"]
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z7signgam"]
    pub static mut signgam: libc::c_int;
}
extern "C" {
    #[link_name = "_Z7rinttol"]
    pub fn rinttol(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z8roundtol"]
    pub fn roundtol(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "_Z4drem"]
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z6finite"]
    pub fn finite(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "_Z5gamma"]
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z11significand"]
    pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct exception {
    pub type_: libc::c_int,
    pub name: *mut libc::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(::core::mem::size_of::<exception>() , 40usize , concat ! (
               "Size of: " , stringify ! ( exception ) ));
    assert_eq! (::core::mem::align_of::<exception>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( exception ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . type_ as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . name as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( name ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg1 as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . arg2 as * const _ as
                usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( arg2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const exception ) ) . retval as * const _ as
                usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( exception ) , "::" ,
                stringify ! ( retval ) ));
}
impl Clone for exception {
    fn clone(&self) -> Self { *self }
}
pub type DioIrqHandler = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioLnaSettings_t {
    LNA_LOW_POWER_MODE = 0,
    LNA_HIGH_SENSITIVITY_MODE = 1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RadioStatus_t {
    pub Fields: __BindgenUnionField<RadioStatus_t__bindgen_ty_1>,
    pub Value: __BindgenUnionField<u8>,
    pub bindgen_union_field: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RadioStatus_t__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_RadioStatus_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<RadioStatus_t__bindgen_ty_1>() , 1usize
               , concat ! (
               "Size of: " , stringify ! ( RadioStatus_t__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<RadioStatus_t__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( RadioStatus_t__bindgen_ty_1 )
                ));
}
impl Clone for RadioStatus_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl RadioStatus_t__bindgen_ty_1 {
    #[inline]
    pub fn CpuBusy(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_CpuBusy(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn DmaBusy(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_DmaBusy(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn CmdStatus(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 28u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_CmdStatus(&mut self, val: u8) {
        let mask = 28u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn ChipMode(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 224u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ChipMode(&mut self, val: u8) {
        let mask = 224u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(CpuBusy: u8, DmaBusy: u8, CmdStatus: u8,
                          ChipMode: u8) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((CpuBusy as u8 as u8) << 0usize) & (1u64 as u8))
                   } | ((DmaBusy as u8 as u8) << 1usize) & (2u64 as u8))
              } | ((CmdStatus as u8 as u8) << 2usize) & (28u64 as u8))
         } | ((ChipMode as u8 as u8) << 5usize) & (224u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_RadioStatus_t() {
    assert_eq!(::core::mem::size_of::<RadioStatus_t>() , 1usize , concat ! (
               "Size of: " , stringify ! ( RadioStatus_t ) ));
    assert_eq! (::core::mem::align_of::<RadioStatus_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( RadioStatus_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioStatus_t ) ) . Fields as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioStatus_t ) , "::"
                , stringify ! ( Fields ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioStatus_t ) ) . Value as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioStatus_t ) , "::"
                , stringify ! ( Value ) ));
}
impl Clone for RadioStatus_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioStates_t {
    RF_IDLE = 0,
    RF_RX_RUNNING = 1,
    RF_TX_RUNNING = 2,
    RF_CAD = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioOperatingModes_t {
    MODE_SLEEP = 0,
    MODE_STDBY_RC = 1,
    MODE_STDBY_XOSC = 2,
    MODE_FS = 3,
    MODE_TX = 4,
    MODE_RX = 5,
    MODE_CAD = 6,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioStandbyModes_t { STDBY_RC = 0, STDBY_XOSC = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioRegulatorModes_t { USE_LDO = 0, USE_DCDC = 1, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioPacketTypes_t {
    PACKET_TYPE_GFSK = 0,
    PACKET_TYPE_LORA = 1,
    PACKET_TYPE_RANGING = 2,
    PACKET_TYPE_FLRC = 3,
    PACKET_TYPE_BLE = 4,
    PACKET_TYPE_NONE = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioRampTimes_t {
    RADIO_RAMP_02_US = 0,
    RADIO_RAMP_04_US = 32,
    RADIO_RAMP_06_US = 64,
    RADIO_RAMP_08_US = 96,
    RADIO_RAMP_10_US = 128,
    RADIO_RAMP_12_US = 160,
    RADIO_RAMP_16_US = 192,
    RADIO_RAMP_20_US = 224,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioLoRaCadSymbols_t {
    LORA_CAD_01_SYMBOL = 0,
    LORA_CAD_02_SYMBOL = 32,
    LORA_CAD_04_SYMBOL = 64,
    LORA_CAD_08_SYMBOL = 96,
    LORA_CAD_16_SYMBOL = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioGfskBleBitrates_t {
    GFSK_BLE_BR_2_000_BW_2_4 = 4,
    GFSK_BLE_BR_1_600_BW_2_4 = 40,
    GFSK_BLE_BR_1_000_BW_2_4 = 76,
    GFSK_BLE_BR_1_000_BW_1_2 = 69,
    GFSK_BLE_BR_0_800_BW_2_4 = 112,
    GFSK_BLE_BR_0_800_BW_1_2 = 105,
    GFSK_BLE_BR_0_500_BW_1_2 = 141,
    GFSK_BLE_BR_0_500_BW_0_6 = 134,
    GFSK_BLE_BR_0_400_BW_1_2 = 177,
    GFSK_BLE_BR_0_400_BW_0_6 = 170,
    GFSK_BLE_BR_0_250_BW_0_6 = 206,
    GFSK_BLE_BR_0_250_BW_0_3 = 199,
    GFSK_BLE_BR_0_125_BW_0_3 = 239,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioGfskBleModIndexes_t {
    GFSK_BLE_MOD_IND_0_35 = 0,
    GFSK_BLE_MOD_IND_0_50 = 1,
    GFSK_BLE_MOD_IND_0_75 = 2,
    GFSK_BLE_MOD_IND_1_00 = 3,
    GFSK_BLE_MOD_IND_1_25 = 4,
    GFSK_BLE_MOD_IND_1_50 = 5,
    GFSK_BLE_MOD_IND_1_75 = 6,
    GFSK_BLE_MOD_IND_2_00 = 7,
    GFSK_BLE_MOD_IND_2_25 = 8,
    GFSK_BLE_MOD_IND_2_50 = 9,
    GFSK_BLE_MOD_IND_2_75 = 10,
    GFSK_BLE_MOD_IND_3_00 = 11,
    GFSK_BLE_MOD_IND_3_25 = 12,
    GFSK_BLE_MOD_IND_3_50 = 13,
    GFSK_BLE_MOD_IND_3_75 = 14,
    GFSK_BLE_MOD_IND_4_00 = 15,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioFlrcBitrates_t {
    FLRC_BR_2_600_BW_2_4 = 4,
    FLRC_BR_2_080_BW_2_4 = 40,
    FLRC_BR_1_300_BW_1_2 = 69,
    FLRC_BR_1_040_BW_1_2 = 105,
    FLRC_BR_0_650_BW_0_6 = 134,
    FLRC_BR_0_520_BW_0_6 = 170,
    FLRC_BR_0_325_BW_0_3 = 199,
    FLRC_BR_0_260_BW_0_3 = 235,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioFlrcCodingRates_t {
    FLRC_CR_1_2 = 0,
    FLRC_CR_3_4 = 2,
    FLRC_CR_1_0 = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioModShapings_t {
    RADIO_MOD_SHAPING_BT_OFF = 0,
    RADIO_MOD_SHAPING_BT_1_0 = 16,
    RADIO_MOD_SHAPING_BT_0_5 = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioLoRaSpreadingFactors_t {
    LORA_SF5 = 80,
    LORA_SF6 = 96,
    LORA_SF7 = 112,
    LORA_SF8 = 128,
    LORA_SF9 = 144,
    LORA_SF10 = 160,
    LORA_SF11 = 176,
    LORA_SF12 = 192,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioLoRaBandwidths_t {
    LORA_BW_0200 = 52,
    LORA_BW_0400 = 38,
    LORA_BW_0800 = 24,
    LORA_BW_1600 = 10,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioLoRaCodingRates_t {
    LORA_CR_4_5 = 1,
    LORA_CR_4_6 = 2,
    LORA_CR_4_7 = 3,
    LORA_CR_4_8 = 4,
    LORA_CR_LI_4_5 = 5,
    LORA_CR_LI_4_6 = 6,
    LORA_CR_LI_4_7 = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioPreambleLengths_t {
    PREAMBLE_LENGTH_04_BITS = 0,
    PREAMBLE_LENGTH_08_BITS = 16,
    PREAMBLE_LENGTH_12_BITS = 32,
    PREAMBLE_LENGTH_16_BITS = 48,
    PREAMBLE_LENGTH_20_BITS = 64,
    PREAMBLE_LENGTH_24_BITS = 80,
    PREAMBLE_LENGTH_28_BITS = 96,
    PREAMBLE_LENGTH_32_BITS = 112,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioFlrcSyncWordLengths_t {
    FLRC_NO_SYNCWORD = 0,
    FLRC_SYNCWORD_LENGTH_4_BYTE = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioSyncWordLengths_t {
    GFSK_SYNCWORD_LENGTH_1_BYTE = 0,
    GFSK_SYNCWORD_LENGTH_2_BYTE = 2,
    GFSK_SYNCWORD_LENGTH_3_BYTE = 4,
    GFSK_SYNCWORD_LENGTH_4_BYTE = 6,
    GFSK_SYNCWORD_LENGTH_5_BYTE = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioSyncWordRxMatchs_t {
    RADIO_RX_MATCH_SYNCWORD_OFF = 0,
    RADIO_RX_MATCH_SYNCWORD_1 = 16,
    RADIO_RX_MATCH_SYNCWORD_2 = 32,
    RADIO_RX_MATCH_SYNCWORD_1_2 = 48,
    RADIO_RX_MATCH_SYNCWORD_3 = 64,
    RADIO_RX_MATCH_SYNCWORD_1_3 = 80,
    RADIO_RX_MATCH_SYNCWORD_2_3 = 96,
    RADIO_RX_MATCH_SYNCWORD_1_2_3 = 112,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioPacketLengthModes_t {
    RADIO_PACKET_FIXED_LENGTH = 0,
    RADIO_PACKET_VARIABLE_LENGTH = 32,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioCrcTypes_t {
    RADIO_CRC_OFF = 0,
    RADIO_CRC_1_BYTES = 16,
    RADIO_CRC_2_BYTES = 32,
    RADIO_CRC_3_BYTES = 48,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioWhiteningModes_t {
    RADIO_WHITENING_ON = 0,
    RADIO_WHITENING_OFF = 8,
}
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_EXPLICIT:
          RadioLoRaPacketLengthsModes_t =
    RadioLoRaPacketLengthsModes_t::LORA_PACKET_VARIABLE_LENGTH;
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_IMPLICIT:
          RadioLoRaPacketLengthsModes_t =
    RadioLoRaPacketLengthsModes_t::LORA_PACKET_FIXED_LENGTH;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioLoRaPacketLengthsModes_t {
    LORA_PACKET_VARIABLE_LENGTH = 0,
    LORA_PACKET_FIXED_LENGTH = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioLoRaCrcModes_t { LORA_CRC_ON = 32, LORA_CRC_OFF = 0, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioLoRaIQModes_t { LORA_IQ_NORMAL = 64, LORA_IQ_INVERTED = 0, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioRangingIdCheckLengths_t {
    RANGING_IDCHECK_LENGTH_08_BITS = 0,
    RANGING_IDCHECK_LENGTH_16_BITS = 1,
    RANGING_IDCHECK_LENGTH_24_BITS = 2,
    RANGING_IDCHECK_LENGTH_32_BITS = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioRangingResultTypes_t {
    RANGING_RESULT_RAW = 0,
    RANGING_RESULT_AVERAGED = 1,
    RANGING_RESULT_DEBIASED = 2,
    RANGING_RESULT_FILTERED = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioBleConnectionStates_t {
    BLE_PAYLOAD_LENGTH_MAX_31_BYTES = 0,
    BLE_PAYLOAD_LENGTH_MAX_37_BYTES = 32,
    BLE_TX_TEST_MODE = 64,
    BLE_PAYLOAD_LENGTH_MAX_255_BYTES = 128,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioBleCrcFields_t { BLE_CRC_OFF = 0, BLE_CRC_3B = 16, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioBlePacketTypes_t {
    BLE_PRBS_9 = 0,
    BLE_PRBS_15 = 12,
    BLE_EYELONG_1_0 = 4,
    BLE_EYELONG_0_1 = 24,
    BLE_EYESHORT_1_0 = 8,
    BLE_EYESHORT_0_1 = 28,
    BLE_ALL_1 = 16,
    BLE_ALL_0 = 20,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioIrqMasks_t {
    IRQ_RADIO_NONE = 0,
    IRQ_TX_DONE = 1,
    IRQ_RX_DONE = 2,
    IRQ_SYNCWORD_VALID = 4,
    IRQ_SYNCWORD_ERROR = 8,
    IRQ_HEADER_VALID = 16,
    IRQ_HEADER_ERROR = 32,
    IRQ_CRC_ERROR = 64,
    IRQ_RANGING_SLAVE_RESPONSE_DONE = 128,
    IRQ_RANGING_SLAVE_REQUEST_DISCARDED = 256,
    IRQ_RANGING_MASTER_RESULT_VALID = 512,
    IRQ_RANGING_MASTER_RESULT_TIMEOUT = 1024,
    IRQ_RANGING_SLAVE_REQUEST_VALID = 2048,
    IRQ_CAD_DONE = 4096,
    IRQ_CAD_ACTIVITY_DETECTED = 8192,
    IRQ_RX_TX_TIMEOUT = 16384,
    IRQ_PREAMBLE_DETECTED = 32768,
    IRQ_RADIO_ALL = 65535,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioDios_t { RADIO_DIO1 = 2, RADIO_DIO2 = 4, RADIO_DIO3 = 8, }
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioTickSizes_t {
    RADIO_TICK_SIZE_0015_US = 0,
    RADIO_TICK_SIZE_0062_US = 1,
    RADIO_TICK_SIZE_1000_US = 2,
    RADIO_TICK_SIZE_4000_US = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioRangingRoles_t {
    RADIO_RANGING_ROLE_SLAVE = 0,
    RADIO_RANGING_ROLE_MASTER = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum RadioCommands_u {
    RADIO_GET_STATUS = 192,
    RADIO_WRITE_REGISTER = 24,
    RADIO_READ_REGISTER = 25,
    RADIO_WRITE_BUFFER = 26,
    RADIO_READ_BUFFER = 27,
    RADIO_SET_SLEEP = 132,
    RADIO_SET_STANDBY = 128,
    RADIO_SET_FS = 193,
    RADIO_SET_TX = 131,
    RADIO_SET_RX = 130,
    RADIO_SET_RXDUTYCYCLE = 148,
    RADIO_SET_CAD = 197,
    RADIO_SET_TXCONTINUOUSWAVE = 209,
    RADIO_SET_TXCONTINUOUSPREAMBLE = 210,
    RADIO_SET_PACKETTYPE = 138,
    RADIO_GET_PACKETTYPE = 3,
    RADIO_SET_RFFREQUENCY = 134,
    RADIO_SET_TXPARAMS = 142,
    RADIO_SET_CADPARAMS = 136,
    RADIO_SET_BUFFERBASEADDRESS = 143,
    RADIO_SET_MODULATIONPARAMS = 139,
    RADIO_SET_PACKETPARAMS = 140,
    RADIO_GET_RXBUFFERSTATUS = 23,
    RADIO_GET_PACKETSTATUS = 29,
    RADIO_GET_RSSIINST = 31,
    RADIO_SET_DIOIRQPARAMS = 141,
    RADIO_GET_IRQSTATUS = 21,
    RADIO_CLR_IRQSTATUS = 151,
    RADIO_CALIBRATE = 137,
    RADIO_SET_REGULATORMODE = 150,
    RADIO_SET_SAVECONTEXT = 213,
    RADIO_SET_AUTOTX = 152,
    RADIO_SET_AUTOFS = 158,
    RADIO_SET_LONGPREAMBLE = 155,
    RADIO_SET_UARTSPEED = 157,
    RADIO_SET_RANGING_ROLE = 163,
}
pub use self::RadioCommands_u as RadioCommands_t;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct TickTime_s {
    pub Step: RadioTickSizes_t,
    pub NbSteps: u16,
}
#[test]
fn bindgen_test_layout_TickTime_s() {
    assert_eq!(::core::mem::size_of::<TickTime_s>() , 8usize , concat ! (
               "Size of: " , stringify ! ( TickTime_s ) ));
    assert_eq! (::core::mem::align_of::<TickTime_s>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( TickTime_s ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TickTime_s ) ) . Step as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( TickTime_s ) , "::" ,
                stringify ! ( Step ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const TickTime_s ) ) . NbSteps as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( TickTime_s ) , "::" ,
                stringify ! ( NbSteps ) ));
}
impl Clone for TickTime_s {
    fn clone(&self) -> Self { *self }
}
pub type TickTime_t = TickTime_s;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ModulationParams_t {
    pub PacketType: RadioPacketTypes_t,
    pub Params: ModulationParams_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ModulationParams_t__bindgen_ty_1 {
    pub Gfsk: ModulationParams_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: ModulationParams_t__bindgen_ty_1__bindgen_ty_2,
    pub Flrc: ModulationParams_t__bindgen_ty_1__bindgen_ty_3,
    pub Ble: ModulationParams_t__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_1 {
    pub BitrateBandwidth: RadioGfskBleBitrates_t,
    pub ModulationIndex: RadioGfskBleModIndexes_t,
    pub ModulationShaping: RadioModShapings_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>()
               , 12usize , concat ! (
               "Size of: " , stringify ! (
               ModulationParams_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . BitrateBandwidth as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( BitrateBandwidth ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . ModulationIndex as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( ModulationIndex ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . ModulationShaping as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( ModulationShaping ) ));
}
impl Clone for ModulationParams_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_2 {
    pub SpreadingFactor: RadioLoRaSpreadingFactors_t,
    pub Bandwidth: RadioLoRaBandwidths_t,
    pub CodingRate: RadioLoRaCodingRates_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>()
               , 12usize , concat ! (
               "Size of: " , stringify ! (
               ModulationParams_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_2 )
                ) . SpreadingFactor as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( SpreadingFactor ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_2 )
                ) . Bandwidth as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( Bandwidth ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_2 )
                ) . CodingRate as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( CodingRate ) ));
}
impl Clone for ModulationParams_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_3 {
    pub BitrateBandwidth: RadioFlrcBitrates_t,
    pub CodingRate: RadioFlrcCodingRates_t,
    pub ModulationShaping: RadioModShapings_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>()
               , 12usize , concat ! (
               "Size of: " , stringify ! (
               ModulationParams_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . BitrateBandwidth as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( BitrateBandwidth ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . CodingRate as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( CodingRate ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . ModulationShaping as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( ModulationShaping ) ));
}
impl Clone for ModulationParams_t__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_4 {
    pub BitrateBandwidth: RadioGfskBleBitrates_t,
    pub ModulationIndex: RadioGfskBleModIndexes_t,
    pub ModulationShaping: RadioModShapings_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>()
               , 12usize , concat ! (
               "Size of: " , stringify ! (
               ModulationParams_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_4 )
                ) . BitrateBandwidth as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( BitrateBandwidth ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_4 )
                ) . ModulationIndex as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( ModulationIndex ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const ModulationParams_t__bindgen_ty_1__bindgen_ty_4 )
                ) . ModulationShaping as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( ModulationShaping ) ));
}
impl Clone for ModulationParams_t__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<ModulationParams_t__bindgen_ty_1>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( ModulationParams_t__bindgen_ty_1 )
               ));
    assert_eq! (::core::mem::align_of::<ModulationParams_t__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                ModulationParams_t__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModulationParams_t__bindgen_ty_1 ) ) .
                Gfsk as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1 ) , "::" , stringify ! ( Gfsk
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModulationParams_t__bindgen_ty_1 ) ) .
                LoRa as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1 ) , "::" , stringify ! ( LoRa
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModulationParams_t__bindgen_ty_1 ) ) .
                Flrc as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1 ) , "::" , stringify ! ( Flrc
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModulationParams_t__bindgen_ty_1 ) ) .
                Ble as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                ModulationParams_t__bindgen_ty_1 ) , "::" , stringify ! ( Ble
                ) ));
}
impl Clone for ModulationParams_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_ModulationParams_t() {
    assert_eq!(::core::mem::size_of::<ModulationParams_t>() , 52usize , concat
               ! ( "Size of: " , stringify ! ( ModulationParams_t ) ));
    assert_eq! (::core::mem::align_of::<ModulationParams_t>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( ModulationParams_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModulationParams_t ) ) . PacketType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( ModulationParams_t ) ,
                "::" , stringify ! ( PacketType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const ModulationParams_t ) ) . Params as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( ModulationParams_t ) ,
                "::" , stringify ! ( Params ) ));
}
impl Clone for ModulationParams_t {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IrqErrorCode_t {
    IRQ_HEADER_ERROR_CODE = 0,
    IRQ_SYNCWORD_ERROR_CODE = 1,
    IRQ_CRC_ERROR_CODE = 2,
    IRQ_RANGING_ON_LORA_ERROR_CODE = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum IrqRangingCode_t {
    IRQ_RANGING_SLAVE_ERROR_CODE = 0,
    IRQ_RANGING_SLAVE_VALID_CODE = 1,
    IRQ_RANGING_MASTER_ERROR_CODE = 2,
    IRQ_RANGING_MASTER_VALID_CODE = 3,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RadioCallbacks_t {
    pub txDone: ::core::option::Option<unsafe extern "C" fn()>,
    pub rxDone: ::core::option::Option<unsafe extern "C" fn()>,
    pub rxSyncWordDone: ::core::option::Option<unsafe extern "C" fn()>,
    pub rxHeaderDone: ::core::option::Option<unsafe extern "C" fn()>,
    pub txTimeout: ::core::option::Option<unsafe extern "C" fn()>,
    pub rxTimeout: ::core::option::Option<unsafe extern "C" fn()>,
    pub rxError: ::core::option::Option<unsafe extern "C" fn(errCode:
                                                                 IrqErrorCode_t)>,
    pub rangingDone: ::core::option::Option<unsafe extern "C" fn(val:
                                                                     IrqRangingCode_t)>,
    pub cadDone: ::core::option::Option<unsafe extern "C" fn(cadFlag: bool)>,
}
#[test]
fn bindgen_test_layout_RadioCallbacks_t() {
    assert_eq!(::core::mem::size_of::<RadioCallbacks_t>() , 72usize , concat !
               ( "Size of: " , stringify ! ( RadioCallbacks_t ) ));
    assert_eq! (::core::mem::align_of::<RadioCallbacks_t>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( RadioCallbacks_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioCallbacks_t ) ) . txDone as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioCallbacks_t ) ,
                "::" , stringify ! ( txDone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioCallbacks_t ) ) . rxDone as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioCallbacks_t ) ,
                "::" , stringify ! ( rxDone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioCallbacks_t ) ) . rxSyncWordDone as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioCallbacks_t ) ,
                "::" , stringify ! ( rxSyncWordDone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioCallbacks_t ) ) . rxHeaderDone as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioCallbacks_t ) ,
                "::" , stringify ! ( rxHeaderDone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioCallbacks_t ) ) . txTimeout as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioCallbacks_t ) ,
                "::" , stringify ! ( txTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioCallbacks_t ) ) . rxTimeout as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioCallbacks_t ) ,
                "::" , stringify ! ( rxTimeout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioCallbacks_t ) ) . rxError as * const
                _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioCallbacks_t ) ,
                "::" , stringify ! ( rxError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioCallbacks_t ) ) . rangingDone as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioCallbacks_t ) ,
                "::" , stringify ! ( rangingDone ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RadioCallbacks_t ) ) . cadDone as * const
                _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( RadioCallbacks_t ) ,
                "::" , stringify ! ( cadDone ) ));
}
impl Clone for RadioCallbacks_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketParams_t {
    pub PacketType: RadioPacketTypes_t,
    pub Params: PacketParams_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketParams_t__bindgen_ty_1 {
    pub Gfsk: PacketParams_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: PacketParams_t__bindgen_ty_1__bindgen_ty_2,
    pub Flrc: PacketParams_t__bindgen_ty_1__bindgen_ty_3,
    pub Ble: PacketParams_t__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_1 {
    pub PreambleLength: RadioPreambleLengths_t,
    pub SyncWordLength: RadioSyncWordLengths_t,
    pub SyncWordMatch: RadioSyncWordRxMatchs_t,
    pub HeaderType: RadioPacketLengthModes_t,
    pub PayloadLength: u8,
    pub CrcLength: RadioCrcTypes_t,
    pub Whitening: RadioWhiteningModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>()
               , 28usize , concat ! (
               "Size of: " , stringify ! (
               PacketParams_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . PreambleLength as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( PreambleLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . SyncWordLength as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( SyncWordLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . SyncWordMatch as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( SyncWordMatch ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . HeaderType as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( HeaderType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . PayloadLength as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( PayloadLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . CrcLength as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( CrcLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_1 )
                ) . Whitening as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( Whitening ) ));
}
impl Clone for PacketParams_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_2 {
    pub PreambleLength: u8,
    pub HeaderType: RadioLoRaPacketLengthsModes_t,
    pub PayloadLength: u8,
    pub CrcMode: RadioLoRaCrcModes_t,
    pub InvertIQ: RadioLoRaIQModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>()
               , 20usize , concat ! (
               "Size of: " , stringify ! (
               PacketParams_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_2 )
                ) . PreambleLength as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( PreambleLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_2 )
                ) . HeaderType as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( HeaderType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_2 )
                ) . PayloadLength as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( PayloadLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_2 )
                ) . CrcMode as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( CrcMode ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_2 )
                ) . InvertIQ as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( InvertIQ ) ));
}
impl Clone for PacketParams_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_3 {
    pub PreambleLength: RadioPreambleLengths_t,
    pub SyncWordLength: RadioFlrcSyncWordLengths_t,
    pub SyncWordMatch: RadioSyncWordRxMatchs_t,
    pub HeaderType: RadioPacketLengthModes_t,
    pub PayloadLength: u8,
    pub CrcLength: RadioCrcTypes_t,
    pub Whitening: RadioWhiteningModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>()
               , 28usize , concat ! (
               "Size of: " , stringify ! (
               PacketParams_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . PreambleLength as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( PreambleLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . SyncWordLength as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( SyncWordLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . SyncWordMatch as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( SyncWordMatch ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . HeaderType as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( HeaderType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . PayloadLength as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( PayloadLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . CrcLength as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( CrcLength ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_3 )
                ) . Whitening as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( Whitening ) ));
}
impl Clone for PacketParams_t__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_4 {
    pub ConnectionState: RadioBleConnectionStates_t,
    pub CrcField: RadioBleCrcFields_t,
    pub BlePacketType: RadioBlePacketTypes_t,
    pub Whitening: RadioWhiteningModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>()
               , 16usize , concat ! (
               "Size of: " , stringify ! (
               PacketParams_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_4 )
                ) . ConnectionState as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( ConnectionState ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_4 )
                ) . CrcField as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( CrcField ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_4 )
                ) . BlePacketType as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( BlePacketType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketParams_t__bindgen_ty_1__bindgen_ty_4 )
                ) . Whitening as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( Whitening ) ));
}
impl Clone for PacketParams_t__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<PacketParams_t__bindgen_ty_1>() ,
               92usize , concat ! (
               "Size of: " , stringify ! ( PacketParams_t__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<PacketParams_t__bindgen_ty_1>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( PacketParams_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketParams_t__bindgen_ty_1 ) ) . Gfsk
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1 ) , "::" , stringify ! ( Gfsk )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketParams_t__bindgen_ty_1 ) ) . LoRa
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1 ) , "::" , stringify ! ( LoRa )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketParams_t__bindgen_ty_1 ) ) . Flrc
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1 ) , "::" , stringify ! ( Flrc )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketParams_t__bindgen_ty_1 ) ) . Ble as
                * const _ as usize } , 76usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketParams_t__bindgen_ty_1 ) , "::" , stringify ! ( Ble )
                ));
}
impl Clone for PacketParams_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PacketParams_t() {
    assert_eq!(::core::mem::size_of::<PacketParams_t>() , 96usize , concat ! (
               "Size of: " , stringify ! ( PacketParams_t ) ));
    assert_eq! (::core::mem::align_of::<PacketParams_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( PacketParams_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketParams_t ) ) . PacketType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PacketParams_t ) , "::"
                , stringify ! ( PacketType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketParams_t ) ) . Params as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PacketParams_t ) , "::"
                , stringify ! ( Params ) ));
}
impl Clone for PacketParams_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t {
    pub packetType: RadioPacketTypes_t,
    pub Params: PacketStatus_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1 {
    pub Gfsk: __BindgenUnionField<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>,
    pub LoRa: __BindgenUnionField<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>,
    pub Flrc: __BindgenUnionField<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>,
    pub Ble: __BindgenUnionField<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>,
    pub bindgen_union_field: [u8; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_1 {
    pub RssiAvg: i8,
    pub RssiSync: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub _bitfield_1: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        let mask = 32u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 64u64 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        let mask = 64u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncError: bool, LengthError: bool, CrcError: bool,
                          AbortError: bool, HeaderReceived: bool,
                          PacketReceived: bool, PacketControlerBusy: bool)
     -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((SyncError as u8 as u8) << 0usize)
                                               & (1u64 as u8))
                                  } |
                                      ((LengthError as u8 as u8) << 1usize) &
                                          (2u64 as u8))
                             } |
                                 ((CrcError as u8 as u8) << 2usize) &
                                     (4u64 as u8))
                        } |
                            ((AbortError as u8 as u8) << 3usize) &
                                (8u64 as u8))
                   } |
                       ((HeaderReceived as u8 as u8) << 4usize) &
                           (16u64 as u8))
              } | ((PacketReceived as u8 as u8) << 5usize) & (32u64 as u8))
         } | ((PacketControlerBusy as u8 as u8) << 6usize) & (64u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn RxNoAck(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_RxNoAck(&mut self, val: bool) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketSent(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(RxNoAck: bool, PacketSent: bool) -> u8 {
        ({ ({ 0 } | ((RxNoAck as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((PacketSent as u8 as u8) << 1usize) & (2u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>()
               , 5usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_1 )
                ) . RssiAvg as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( RssiAvg ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_1 )
                ) . RssiSync as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( RssiSync ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_1 )
                ) . ErrorStatus as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( ErrorStatus ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_1 )
                ) . TxRxStatus as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_1 ) , "::" ,
                stringify ! ( TxRxStatus ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 7u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        let mask = 7u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> u8 {
        ({ 0 } | ((SyncAddrStatus as u8 as u8) << 0usize) & (7u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_2 {
    pub RssiPkt: i8,
    pub SnrPkt: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
    pub _bitfield_1: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        let mask = 32u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 64u64 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        let mask = 64u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncError: bool, LengthError: bool, CrcError: bool,
                          AbortError: bool, HeaderReceived: bool,
                          PacketReceived: bool, PacketControlerBusy: bool)
     -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((SyncError as u8 as u8) << 0usize)
                                               & (1u64 as u8))
                                  } |
                                      ((LengthError as u8 as u8) << 1usize) &
                                          (2u64 as u8))
                             } |
                                 ((CrcError as u8 as u8) << 2usize) &
                                     (4u64 as u8))
                        } |
                            ((AbortError as u8 as u8) << 3usize) &
                                (8u64 as u8))
                   } |
                       ((HeaderReceived as u8 as u8) << 4usize) &
                           (16u64 as u8))
              } | ((PacketReceived as u8 as u8) << 5usize) & (32u64 as u8))
         } | ((PacketControlerBusy as u8 as u8) << 6usize) & (64u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    #[inline]
    pub fn RxNoAck(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_RxNoAck(&mut self, val: bool) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketSent(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(RxNoAck: bool, PacketSent: bool) -> u8 {
        ({ ({ 0 } | ((RxNoAck as u8 as u8) << 0usize) & (1u64 as u8)) } |
             ((PacketSent as u8 as u8) << 1usize) & (2u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>()
               , 5usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_2 )
                ) . RssiPkt as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( RssiPkt ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_2 )
                ) . SnrPkt as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( SnrPkt ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_2 )
                ) . ErrorStatus as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( ErrorStatus ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_2 )
                ) . TxRxStatus as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_2 ) , "::" ,
                stringify ! ( TxRxStatus ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 7u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        let mask = 7u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> u8 {
        ({ 0 } | ((SyncAddrStatus as u8 as u8) << 0usize) & (7u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_3 {
    pub RssiAvg: i8,
    pub RssiSync: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
    pub _bitfield_1: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        let mask = 32u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 64u64 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        let mask = 64u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncError: bool, LengthError: bool, CrcError: bool,
                          AbortError: bool, HeaderReceived: bool,
                          PacketReceived: bool, PacketControlerBusy: bool)
     -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((SyncError as u8 as u8) << 0usize)
                                               & (1u64 as u8))
                                  } |
                                      ((LengthError as u8 as u8) << 1usize) &
                                          (2u64 as u8))
                             } |
                                 ((CrcError as u8 as u8) << 2usize) &
                                     (4u64 as u8))
                        } |
                            ((AbortError as u8 as u8) << 3usize) &
                                (8u64 as u8))
                   } |
                       ((HeaderReceived as u8 as u8) << 4usize) &
                           (16u64 as u8))
              } | ((PacketReceived as u8 as u8) << 5usize) & (32u64 as u8))
         } | ((PacketControlerBusy as u8 as u8) << 6usize) & (64u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    #[inline]
    pub fn RxPid(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 3u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_RxPid(&mut self, val: u8) {
        let mask = 3u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn RxNoAck(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_RxNoAck(&mut self, val: bool) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn RxPidErr(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_RxPidErr(&mut self, val: bool) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketSent(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(RxPid: u8, RxNoAck: bool, RxPidErr: bool,
                          PacketSent: bool) -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((RxPid as u8 as u8) << 0usize) & (3u64 as u8))
                   } | ((RxNoAck as u8 as u8) << 2usize) & (4u64 as u8))
              } | ((RxPidErr as u8 as u8) << 3usize) & (8u64 as u8))
         } | ((PacketSent as u8 as u8) << 4usize) & (16u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>()
               , 5usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_3 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_3 )
                ) . RssiAvg as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( RssiAvg ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_3 )
                ) . RssiSync as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( RssiSync ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_3 )
                ) . ErrorStatus as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( ErrorStatus ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_3 )
                ) . TxRxStatus as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_3 ) , "::" ,
                stringify ! ( TxRxStatus ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_3 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 7u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        let mask = 7u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> u8 {
        ({ 0 } | ((SyncAddrStatus as u8 as u8) << 0usize) & (7u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_4 {
    pub RssiAvg: i8,
    pub RssiSync: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
    pub _bitfield_1: u8,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        let mask = 32u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 64u64 as u8;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        let mask = 64u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncError: bool, LengthError: bool, CrcError: bool,
                          AbortError: bool, HeaderReceived: bool,
                          PacketReceived: bool, PacketControlerBusy: bool)
     -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({
                                      ({ 0 } |
                                           ((SyncError as u8 as u8) << 0usize)
                                               & (1u64 as u8))
                                  } |
                                      ((LengthError as u8 as u8) << 1usize) &
                                          (2u64 as u8))
                             } |
                                 ((CrcError as u8 as u8) << 2usize) &
                                     (4u64 as u8))
                        } |
                            ((AbortError as u8 as u8) << 3usize) &
                                (8u64 as u8))
                   } |
                       ((HeaderReceived as u8 as u8) << 4usize) &
                           (16u64 as u8))
              } | ((PacketReceived as u8 as u8) << 5usize) & (32u64 as u8))
         } | ((PacketControlerBusy as u8 as u8) << 6usize) & (64u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>()
               , 1usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    #[inline]
    pub fn PacketSent(&self) -> bool {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(PacketSent: bool) -> u8 {
        ({ 0 } | ((PacketSent as u8 as u8) << 0usize) & (1u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>()
               , 5usize , concat ! (
               "Size of: " , stringify ! (
               PacketStatus_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>()
                , 1usize , concat ! (
                "Alignment of " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_4 ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_4 )
                ) . RssiAvg as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( RssiAvg ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_4 )
                ) . RssiSync as * const _ as usize } , 1usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( RssiSync ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_4 )
                ) . ErrorStatus as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( ErrorStatus ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const PacketStatus_t__bindgen_ty_1__bindgen_ty_4 )
                ) . TxRxStatus as * const _ as usize } , 3usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1__bindgen_ty_4 ) , "::" ,
                stringify ! ( TxRxStatus ) ));
}
impl Clone for PacketStatus_t__bindgen_ty_1__bindgen_ty_4 {
    fn clone(&self) -> Self { *self }
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_4 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 7u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        let mask = 7u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> u8 {
        ({ 0 } | ((SyncAddrStatus as u8 as u8) << 0usize) & (7u64 as u8))
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t__bindgen_ty_1>() , 5usize
               , concat ! (
               "Size of: " , stringify ! ( PacketStatus_t__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t__bindgen_ty_1>() ,
                1usize , concat ! (
                "Alignment of " , stringify ! ( PacketStatus_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketStatus_t__bindgen_ty_1 ) ) . Gfsk
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1 ) , "::" , stringify ! ( Gfsk )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketStatus_t__bindgen_ty_1 ) ) . LoRa
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1 ) , "::" , stringify ! ( LoRa )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketStatus_t__bindgen_ty_1 ) ) . Flrc
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1 ) , "::" , stringify ! ( Flrc )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketStatus_t__bindgen_ty_1 ) ) . Ble as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                PacketStatus_t__bindgen_ty_1 ) , "::" , stringify ! ( Ble )
                ));
}
impl Clone for PacketStatus_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_PacketStatus_t() {
    assert_eq!(::core::mem::size_of::<PacketStatus_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( PacketStatus_t ) ));
    assert_eq! (::core::mem::align_of::<PacketStatus_t>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( PacketStatus_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketStatus_t ) ) . packetType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( PacketStatus_t ) , "::"
                , stringify ! ( packetType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const PacketStatus_t ) ) . Params as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( PacketStatus_t ) , "::"
                , stringify ! ( Params ) ));
}
impl Clone for PacketStatus_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RxCounter_t {
    pub packetType: RadioPacketTypes_t,
    pub Params: RxCounter_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RxCounter_t__bindgen_ty_1 {
    pub Gfsk: __BindgenUnionField<RxCounter_t__bindgen_ty_1__bindgen_ty_1>,
    pub LoRa: __BindgenUnionField<RxCounter_t__bindgen_ty_1__bindgen_ty_2>,
    pub bindgen_union_field: [u16; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RxCounter_t__bindgen_ty_1__bindgen_ty_1 {
    pub PacketReceived: u16,
    pub CrcError: u16,
    pub LengthError: u16,
    pub SyncwordError: u16,
}
#[test]
fn bindgen_test_layout_RxCounter_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>()
               , 8usize , concat ! (
               "Size of: " , stringify ! (
               RxCounter_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                RxCounter_t__bindgen_ty_1__bindgen_ty_1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t__bindgen_ty_1__bindgen_ty_1 )
                ) . PacketReceived as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                RxCounter_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( PacketReceived ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t__bindgen_ty_1__bindgen_ty_1 )
                ) . CrcError as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                RxCounter_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( CrcError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t__bindgen_ty_1__bindgen_ty_1 )
                ) . LengthError as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                RxCounter_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( LengthError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t__bindgen_ty_1__bindgen_ty_1 )
                ) . SyncwordError as * const _ as usize } , 6usize , concat !
                (
                "Alignment of field: " , stringify ! (
                RxCounter_t__bindgen_ty_1__bindgen_ty_1 ) , "::" , stringify !
                ( SyncwordError ) ));
}
impl Clone for RxCounter_t__bindgen_ty_1__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct RxCounter_t__bindgen_ty_1__bindgen_ty_2 {
    pub PacketReceived: u16,
    pub CrcError: u16,
    pub HeaderValid: u16,
}
#[test]
fn bindgen_test_layout_RxCounter_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(::core::mem::size_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>()
               , 6usize , concat ! (
               "Size of: " , stringify ! (
               RxCounter_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (::core::mem::align_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>()
                , 2usize , concat ! (
                "Alignment of " , stringify ! (
                RxCounter_t__bindgen_ty_1__bindgen_ty_2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t__bindgen_ty_1__bindgen_ty_2 )
                ) . PacketReceived as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                RxCounter_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify !
                ( PacketReceived ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t__bindgen_ty_1__bindgen_ty_2 )
                ) . CrcError as * const _ as usize } , 2usize , concat ! (
                "Alignment of field: " , stringify ! (
                RxCounter_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify !
                ( CrcError ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t__bindgen_ty_1__bindgen_ty_2 )
                ) . HeaderValid as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                RxCounter_t__bindgen_ty_1__bindgen_ty_2 ) , "::" , stringify !
                ( HeaderValid ) ));
}
impl Clone for RxCounter_t__bindgen_ty_1__bindgen_ty_2 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_RxCounter_t__bindgen_ty_1() {
    assert_eq!(::core::mem::size_of::<RxCounter_t__bindgen_ty_1>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( RxCounter_t__bindgen_ty_1 ) ));
    assert_eq! (::core::mem::align_of::<RxCounter_t__bindgen_ty_1>() , 2usize
                , concat ! (
                "Alignment of " , stringify ! ( RxCounter_t__bindgen_ty_1 )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t__bindgen_ty_1 ) ) . Gfsk as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                RxCounter_t__bindgen_ty_1 ) , "::" , stringify ! ( Gfsk ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t__bindgen_ty_1 ) ) . LoRa as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                RxCounter_t__bindgen_ty_1 ) , "::" , stringify ! ( LoRa ) ));
}
impl Clone for RxCounter_t__bindgen_ty_1 {
    fn clone(&self) -> Self { *self }
}
#[test]
fn bindgen_test_layout_RxCounter_t() {
    assert_eq!(::core::mem::size_of::<RxCounter_t>() , 12usize , concat ! (
               "Size of: " , stringify ! ( RxCounter_t ) ));
    assert_eq! (::core::mem::align_of::<RxCounter_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( RxCounter_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t ) ) . packetType as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( RxCounter_t ) , "::" ,
                stringify ! ( packetType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const RxCounter_t ) ) . Params as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( RxCounter_t ) , "::" ,
                stringify ! ( Params ) ));
}
impl Clone for RxCounter_t {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct CalibrationParams_t {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_CalibrationParams_t() {
    assert_eq!(::core::mem::size_of::<CalibrationParams_t>() , 1usize , concat
               ! ( "Size of: " , stringify ! ( CalibrationParams_t ) ));
    assert_eq! (::core::mem::align_of::<CalibrationParams_t>() , 1usize ,
                concat ! (
                "Alignment of " , stringify ! ( CalibrationParams_t ) ));
}
impl Clone for CalibrationParams_t {
    fn clone(&self) -> Self { *self }
}
impl CalibrationParams_t {
    #[inline]
    pub fn RC64KEnable(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_RC64KEnable(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn RC13MEnable(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_RC13MEnable(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn PLLEnable(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_PLLEnable(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn ADCPulseEnable(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ADCPulseEnable(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn ADCBulkNEnable(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 16u64 as u8;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ADCBulkNEnable(&mut self, val: u8) {
        let mask = 16u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn ADCBulkPEnable(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 32u64 as u8;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_ADCBulkPEnable(&mut self, val: u8) {
        let mask = 32u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(RC64KEnable: u8, RC13MEnable: u8, PLLEnable: u8,
                          ADCPulseEnable: u8, ADCBulkNEnable: u8,
                          ADCBulkPEnable: u8) -> u8 {
        ({
             ({
                  ({
                       ({
                            ({
                                 ({ 0 } |
                                      ((RC64KEnable as u8 as u8) << 0usize) &
                                          (1u64 as u8))
                             } |
                                 ((RC13MEnable as u8 as u8) << 1usize) &
                                     (2u64 as u8))
                        } |
                            ((PLLEnable as u8 as u8) << 2usize) &
                                (4u64 as u8))
                   } |
                       ((ADCPulseEnable as u8 as u8) << 3usize) &
                           (8u64 as u8))
              } | ((ADCBulkNEnable as u8 as u8) << 4usize) & (16u64 as u8))
         } | ((ADCBulkPEnable as u8 as u8) << 5usize) & (32u64 as u8))
    }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct SleepParams_t {
    pub _bitfield_1: u8,
    pub __bindgen_align: [u8; 0usize],
}
#[test]
fn bindgen_test_layout_SleepParams_t() {
    assert_eq!(::core::mem::size_of::<SleepParams_t>() , 1usize , concat ! (
               "Size of: " , stringify ! ( SleepParams_t ) ));
    assert_eq! (::core::mem::align_of::<SleepParams_t>() , 1usize , concat ! (
                "Alignment of " , stringify ! ( SleepParams_t ) ));
}
impl Clone for SleepParams_t {
    fn clone(&self) -> Self { *self }
}
impl SleepParams_t {
    #[inline]
    pub fn WakeUpRTC(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 1u64 as u8;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_WakeUpRTC(&mut self, val: u8) {
        let mask = 1u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn InstructionRamRetention(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 2u64 as u8;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_InstructionRamRetention(&mut self, val: u8) {
        let mask = 2u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn DataBufferRetention(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 4u64 as u8;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_DataBufferRetention(&mut self, val: u8) {
        let mask = 4u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn DataRamRetention(&self) -> u8 {
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        let mask = 8u64 as u8;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::core::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_DataRamRetention(&mut self, val: u8) {
        let mask = 8u64 as u8;
        let val = val as u8 as u8;
        let mut unit_field_val: u8 = unsafe { ::core::mem::uninitialized() };
        unsafe {
            ::core::ptr::copy_nonoverlapping(&self._bitfield_1 as *const _ as
                                                 *const u8,
                                             &mut unit_field_val as *mut u8 as
                                                 *mut u8,
                                             ::core::mem::size_of::<u8>())
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::core::ptr::copy_nonoverlapping(&unit_field_val as *const _ as
                                                 *const u8,
                                             &mut self._bitfield_1 as *mut _
                                                 as *mut u8,
                                             ::core::mem::size_of::<u8>());
        }
    }
    #[inline]
    pub fn new_bitfield_1(WakeUpRTC: u8, InstructionRamRetention: u8,
                          DataBufferRetention: u8, DataRamRetention: u8)
     -> u8 {
        ({
             ({
                  ({
                       ({ 0 } |
                            ((WakeUpRTC as u8 as u8) << 0usize) &
                                (1u64 as u8))
                   } |
                       ((InstructionRamRetention as u8 as u8) << 1usize) &
                           (2u64 as u8))
              } |
                  ((DataBufferRetention as u8 as u8) << 2usize) &
                      (4u64 as u8))
         } | ((DataRamRetention as u8 as u8) << 3usize) & (8u64 as u8))
    }
}
extern "C" {
    #[link_name = "_Z22SX1280GetLoRaBandwidth"]
    pub fn SX1280GetLoRaBandwidth() -> i32;
}
extern "C" {
    #[link_name = "_Z37SX1280GetRangingCorrectionPerSfBwGain"]
    pub fn SX1280GetRangingCorrectionPerSfBwGain(sf:
                                                     RadioLoRaSpreadingFactors_t,
                                                 bw: RadioLoRaBandwidths_t,
                                                 gain: i8) -> f64;
}
extern "C" {
    #[link_name = "_Z38SX1280ComputeRangingCorrectionPolynome"]
    pub fn SX1280ComputeRangingCorrectionPolynome(sf:
                                                      RadioLoRaSpreadingFactors_t,
                                                  bw: RadioLoRaBandwidths_t,
                                                  median: f64) -> f64;
}
extern "C" {
    #[link_name = "_Z14SX1280OnDioIrq"]
    pub fn SX1280OnDioIrq();
}
extern "C" {
    #[link_name = "_Z20SX1280SetRangingRole"]
    pub fn SX1280SetRangingRole(role: RadioRangingRoles_t);
}
extern "C" {
    #[link_name = "_Z10SX1280Init"]
    pub fn SX1280Init(callbacks: *mut RadioCallbacks_t);
}
extern "C" {
    #[link_name = "_Z20SX1280SetPollingMode"]
    pub fn SX1280SetPollingMode();
}
extern "C" {
    #[link_name = "_Z22SX1280SetInterruptMode"]
    pub fn SX1280SetInterruptMode();
}
extern "C" {
    #[link_name = "_Z25SX1280SetRegistersDefault"]
    pub fn SX1280SetRegistersDefault();
}
extern "C" {
    #[link_name = "_Z24SX1280GetFirmwareVersion"]
    pub fn SX1280GetFirmwareVersion() -> u16;
}
extern "C" {
    #[link_name = "_Z15SX1280GetOpMode"]
    pub fn SX1280GetOpMode() -> RadioOperatingModes_t;
}
extern "C" {
    #[link_name = "_Z15SX1280GetStatus"]
    pub fn SX1280GetStatus() -> RadioStatus_t;
}
extern "C" {
    #[link_name = "_Z14SX1280SetSleep"]
    pub fn SX1280SetSleep(sleepConfig: SleepParams_t);
}
extern "C" {
    #[link_name = "_Z16SX1280SetStandby"]
    pub fn SX1280SetStandby(mode: RadioStandbyModes_t);
}
extern "C" {
    #[link_name = "_Z11SX1280SetFs"]
    pub fn SX1280SetFs();
}
extern "C" {
    #[link_name = "_Z11SX1280SetTx"]
    pub fn SX1280SetTx(timeout: TickTime_t);
}
extern "C" {
    #[link_name = "_Z11SX1280SetRx"]
    pub fn SX1280SetRx(timeout: TickTime_t);
}
extern "C" {
    #[link_name = "_Z20SX1280SetRxDutyCycle"]
    pub fn SX1280SetRxDutyCycle(Step: RadioTickSizes_t, NbStepRx: u16,
                                RxNbStepSleep: u16);
}
extern "C" {
    #[link_name = "_Z12SX1280SetCad"]
    pub fn SX1280SetCad();
}
extern "C" {
    #[link_name = "_Z25SX1280SetTxContinuousWave"]
    pub fn SX1280SetTxContinuousWave();
}
extern "C" {
    #[link_name = "_Z29SX1280SetTxContinuousPreamble"]
    pub fn SX1280SetTxContinuousPreamble();
}
extern "C" {
    #[link_name = "_Z19SX1280SetPacketType"]
    pub fn SX1280SetPacketType(packetType: RadioPacketTypes_t);
}
extern "C" {
    #[link_name = "_Z19SX1280GetPacketType"]
    pub fn SX1280GetPacketType() -> RadioPacketTypes_t;
}
extern "C" {
    #[link_name = "_Z20SX1280SetRfFrequency"]
    pub fn SX1280SetRfFrequency(frequency: u32);
}
extern "C" {
    #[link_name = "_Z17SX1280SetTxParams"]
    pub fn SX1280SetTxParams(power: i8, rampTime: RadioRampTimes_t);
}
extern "C" {
    #[link_name = "_Z18SX1280SetCadParams"]
    pub fn SX1280SetCadParams(cadSymbolNum: RadioLoRaCadSymbols_t);
}
extern "C" {
    #[link_name = "_Z28SX1280SetBufferBaseAddresses"]
    pub fn SX1280SetBufferBaseAddresses(txBaseAddress: u8, rxBaseAddress: u8);
}
extern "C" {
    #[link_name = "_Z25SX1280SetModulationParams"]
    pub fn SX1280SetModulationParams(modParams: *mut ModulationParams_t);
}
extern "C" {
    #[link_name = "_Z21SX1280SetPacketParams"]
    pub fn SX1280SetPacketParams(packetParams: *mut PacketParams_t);
}
extern "C" {
    #[link_name = "_Z23SX1280GetRxBufferStatus"]
    pub fn SX1280GetRxBufferStatus(payloadLength: *mut u8,
                                   rxStartBuffer: *mut u8);
}
extern "C" {
    #[link_name = "_Z21SX1280GetPacketStatus"]
    pub fn SX1280GetPacketStatus(pktStatus: *mut PacketStatus_t);
}
extern "C" {
    #[link_name = "_Z17SX1280GetRssiInst"]
    pub fn SX1280GetRssiInst() -> i8;
}
extern "C" {
    #[link_name = "_Z21SX1280SetDioIrqParams"]
    pub fn SX1280SetDioIrqParams(irqMask: u16, dio1Mask: u16, dio2Mask: u16,
                                 dio3Mask: u16);
}
extern "C" {
    #[link_name = "_Z18SX1280GetIrqStatus"]
    pub fn SX1280GetIrqStatus() -> u16;
}
extern "C" {
    #[link_name = "_Z20SX1280ClearIrqStatus"]
    pub fn SX1280ClearIrqStatus(irq: u16);
}
extern "C" {
    #[link_name = "_Z15SX1280Calibrate"]
    pub fn SX1280Calibrate(calibParam: CalibrationParams_t);
}
extern "C" {
    #[link_name = "_Z22SX1280SetRegulatorMode"]
    pub fn SX1280SetRegulatorMode(mode: RadioRegulatorModes_t);
}
extern "C" {
    #[link_name = "_Z20SX1280SetSaveContext"]
    pub fn SX1280SetSaveContext();
}
extern "C" {
    #[link_name = "_Z15SX1280SetAutoTx"]
    pub fn SX1280SetAutoTx(time: u16);
}
extern "C" {
    #[link_name = "_Z16SX1280StopAutoTx"]
    pub fn SX1280StopAutoTx();
}
extern "C" {
    #[link_name = "_Z15SX1280SetAutoFS"]
    pub fn SX1280SetAutoFS(enable: u8);
}
extern "C" {
    #[link_name = "_Z21SX1280SetLongPreamble"]
    pub fn SX1280SetLongPreamble(enable: u8);
}
extern "C" {
    #[link_name = "_Z16SX1280SetPayload"]
    pub fn SX1280SetPayload(payload: *mut u8, size: u8);
}
extern "C" {
    #[link_name = "_Z16SX1280GetPayload"]
    pub fn SX1280GetPayload(payload: *mut u8, size: *mut u8, maxSize: u8)
     -> u8;
}
extern "C" {
    #[link_name = "_Z17SX1280SendPayload"]
    pub fn SX1280SendPayload(payload: *mut u8, size: u8, timeout: TickTime_t);
}
extern "C" {
    #[link_name = "_Z17SX1280SetSyncWord"]
    pub fn SX1280SetSyncWord(syncWordIdx: u8, syncWord: *mut u8) -> u8;
}
extern "C" {
    #[link_name = "_Z31SX1280SetSyncWordErrorTolerance"]
    pub fn SX1280SetSyncWordErrorTolerance(errorBits: u8);
}
extern "C" {
    #[link_name = "_Z16SX1280SetCrcSeed"]
    pub fn SX1280SetCrcSeed(seed: u16);
}
extern "C" {
    #[link_name = "_Z25SX1280SetBleAccessAddress"]
    pub fn SX1280SetBleAccessAddress(accessAddress: u32);
}
extern "C" {
    #[link_name = "_Z35SX1280SetBleAdvertizerAccessAddress"]
    pub fn SX1280SetBleAdvertizerAccessAddress();
}
extern "C" {
    #[link_name = "_Z22SX1280SetCrcPolynomial"]
    pub fn SX1280SetCrcPolynomial(seed: u16);
}
extern "C" {
    #[link_name = "_Z22SX1280SetWhiteningSeed"]
    pub fn SX1280SetWhiteningSeed(seed: u8);
}
extern "C" {
    #[link_name = "_Z22SX1280EnableManualGain"]
    pub fn SX1280EnableManualGain();
}
extern "C" {
    #[link_name = "_Z23SX1280DisableManualGain"]
    pub fn SX1280DisableManualGain();
}
extern "C" {
    #[link_name = "_Z24SX1280SetManualGainValue"]
    pub fn SX1280SetManualGainValue(gain: u8);
}
extern "C" {
    #[link_name = "_Z23SX1280SetLNAGainSetting"]
    pub fn SX1280SetLNAGainSetting(lnaSetting: RadioLnaSettings_t);
}
extern "C" {
    #[link_name = "_Z24SX1280SetRangingIdLength"]
    pub fn SX1280SetRangingIdLength(length: RadioRangingIdCheckLengths_t);
}
extern "C" {
    #[link_name = "_Z29SX1280SetDeviceRangingAddress"]
    pub fn SX1280SetDeviceRangingAddress(address: u32);
}
extern "C" {
    #[link_name = "_Z30SX1280SetRangingRequestAddress"]
    pub fn SX1280SetRangingRequestAddress(address: u32);
}
extern "C" {
    #[link_name = "_Z22SX1280GetRangingResult"]
    pub fn SX1280GetRangingResult(resultType: RadioRangingResultTypes_t)
     -> f64;
}
extern "C" {
    #[link_name = "_Z27SX1280SetRangingCalibration"]
    pub fn SX1280SetRangingCalibration(cal: u16);
}
extern "C" {
    #[link_name = "_Z44SX1280GetRangingPowerDeltaThresholdIndicator"]
    pub fn SX1280GetRangingPowerDeltaThresholdIndicator() -> u8;
}
extern "C" {
    #[link_name = "_Z30SX1280RangingClearFilterResult"]
    pub fn SX1280RangingClearFilterResult();
}
extern "C" {
    #[link_name = "_Z32SX1280RangingSetFilterNumSamples"]
    pub fn SX1280RangingSetFilterNumSamples(numSample: u8);
}
extern "C" {
    #[link_name = "_Z23SX1280GetFrequencyError"]
    pub fn SX1280GetFrequencyError() -> f64;
}
extern "C" {
    #[link_name = "_Z17SX1280ProcessIrqs"]
    pub fn SX1280ProcessIrqs();
}
extern "C" {
    #[link_name = "_Z25SX1280ClearInstructionRam"]
    pub fn SX1280ClearInstructionRam();
}
extern "C" {
    #[link_name = "_Z22SX1280ParseHexFileLine"]
    pub fn SX1280ParseHexFileLine(line: *mut libc::c_char) -> i8;
}
extern "C" {
    #[link_name = "_Z26SX1280GetHexFileLineFields"]
    pub fn SX1280GetHexFileLineFields(line: *mut libc::c_char, bytes: *mut u8,
                                      addr: *mut u16, num: *mut u16,
                                      code: *mut u8) -> i8;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(::core::mem::size_of::<__va_list_tag>() , 24usize , concat ! (
               "Size of: " , stringify ! ( __va_list_tag ) ));
    assert_eq! (::core::mem::align_of::<__va_list_tag>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( __va_list_tag ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . gp_offset as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( gp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . fp_offset as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( fp_offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . overflow_arg_area as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( overflow_arg_area ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __va_list_tag ) ) . reg_save_area as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( __va_list_tag ) , "::"
                , stringify ! ( reg_save_area ) ));
}
impl Clone for __va_list_tag {
    fn clone(&self) -> Self { *self }
}
