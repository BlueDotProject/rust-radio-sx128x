#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
use libc;

/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 101304;
pub const FP_SUPERNORMAL: u32 = 6;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const DOMAIN: u32 = 1;
pub const SING: u32 = 2;
pub const OVERFLOW: u32 = 3;
pub const UNDERFLOW: u32 = 4;
pub const TLOSS: u32 = 5;
pub const PLOSS: u32 = 6;
pub const SX1280_DEBUG: u32 = 0;
pub const XTAL_FREQ: u32 = 52000000;
pub const AUTO_RX_TX_OFFSET: u32 = 33;
pub const REG_LR_FIRMWARE_VERSION_MSB: u32 = 339;
pub const REG_LR_CRCSEEDBASEADDR: u32 = 2504;
pub const REG_LR_CRCPOLYBASEADDR: u32 = 2502;
pub const REG_LR_WHITSEEDBASEADDR: u32 = 2501;
pub const REG_LR_RANGINGIDCHECKLENGTH: u32 = 2353;
pub const REG_LR_DEVICERANGINGADDR: u32 = 2326;
pub const REG_LR_REQUESTRANGINGADDR: u32 = 2322;
pub const REG_LR_RANGINGRESULTCONFIG: u32 = 2340;
pub const MASK_RANGINGMUXSEL: u32 = 207;
pub const REG_LR_RANGINGRESULTBASEADDR: u32 = 2401;
pub const REG_LR_RANGINGRESULTSFREEZE: u32 = 2431;
pub const REG_LR_RANGINGRERXTXDELAYCAL: u32 = 2348;
pub const REG_LR_RANGINGFILTERWINDOWSIZE: u32 = 2334;
pub const REG_LR_RANGINGRESULTCLEARREG: u32 = 2339;
pub const REG_RANGING_RSSI: u32 = 2404;
pub const DEFAULT_RANGING_FILTER_SIZE: u32 = 127;
pub const REG_LR_PACKETPARAMS: u32 = 2307;
pub const REG_LR_PAYLOADLENGTH: u32 = 2305;
pub const IRAM_START_ADDRESS: u32 = 32768;
pub const IRAM_SIZE: u32 = 16384;
pub const REG_LR_SYNCWORDBASEADDRESS1: u32 = 2510;
pub const REG_LR_SYNCWORDBASEADDRESS2: u32 = 2515;
pub const REG_LR_SYNCWORDBASEADDRESS3: u32 = 2520;
pub const REG_LR_ESTIMATED_FREQUENCY_ERROR_MSB: u32 = 2388;
pub const REG_LR_ESTIMATED_FREQUENCY_ERROR_MASK: u32 = 1048575;
pub const REG_LR_SYNCWORDTOLERANCE: u32 = 2509;
pub const REG_LR_BLE_ACCESS_ADDRESS: u32 = 2511;
pub const BLE_ADVERTIZER_ACCESS_ADDRESS: u32 = 2391391958;
pub const REG_LNA_REGIME: u32 = 2193;
pub const MASK_LNA_REGIME: u32 = 192;
pub const REG_ENABLE_MANUAL_GAIN_CONTROL: u32 = 2207;
pub const MASK_MANUAL_GAIN_CONTROL: u32 = 128;
pub const REG_DEMOD_DETECTION: u32 = 2197;
pub const MASK_DEMOD_DETECTION: u32 = 254;
pub const REG_MANUAL_GAIN_VALUE: u32 = 2206;
pub const MASK_MANUAL_GAIN_VALUE: u32 = 240;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = libc::c_schar;
pub type __uint8_t = libc::c_uchar;
pub type __int16_t = libc::c_short;
pub type __uint16_t = libc::c_ushort;
pub type __int32_t = libc::c_int;
pub type __uint32_t = libc::c_uint;
pub type __int64_t = libc::c_longlong;
pub type __uint64_t = libc::c_ulonglong;
pub type __darwin_intptr_t = libc::c_long;
pub type __darwin_natural_t = libc::c_uint;
pub type __darwin_ct_rune_t = libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [libc::c_char; 128usize],
    pub _mbstateL: libc::c_longlong,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = libc::c_long;
pub type __darwin_size_t = libc::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = libc::c_int;
pub type __darwin_clock_t = libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = libc::c_long;
pub type __darwin_time_t = libc::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = libc::c_uint;
pub type __darwin_fsfilcnt_t = libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [libc::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [libc::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    pub __arg: *mut libc::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::core::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::core::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: libc::c_long,
    pub __opaque: [libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: libc::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [libc::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::core::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = libc::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = libc::c_uchar;
pub type u_int16_t = libc::c_ushort;
pub type u_int32_t = libc::c_uint;
pub type u_int64_t = libc::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = libc::c_long;
pub type uintmax_t = libc::c_ulong;
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    #[link_name = "\u{1}___math_errhandling"]
    pub fn __math_errhandling() -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}___fpclassifyf"]
    pub fn __fpclassifyf(arg1: f32) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}___fpclassifyd"]
    pub fn __fpclassifyd(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}___fpclassifyl"]
    pub fn __fpclassifyl(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}_acosf"]
    pub fn acosf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_acos"]
    pub fn acos(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_acosl"]
    pub fn acosl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinf"]
    pub fn asinf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_asin"]
    pub fn asin(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinl"]
    pub fn asinl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanf"]
    pub fn atanf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_atan"]
    pub fn atan(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanl"]
    pub fn atanl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atan2f"]
    pub fn atan2f(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_atan2"]
    pub fn atan2(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atan2l"]
    pub fn atan2l(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cosf"]
    pub fn cosf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_cos"]
    pub fn cos(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cosl"]
    pub fn cosl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinf"]
    pub fn sinf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sin"]
    pub fn sin(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinl"]
    pub fn sinl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanf"]
    pub fn tanf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_tan"]
    pub fn tan(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanl"]
    pub fn tanl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_acoshf"]
    pub fn acoshf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_acosh"]
    pub fn acosh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_acoshl"]
    pub fn acoshl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinhf"]
    pub fn asinhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_asinh"]
    pub fn asinh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_asinhl"]
    pub fn asinhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanhf"]
    pub fn atanhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_atanh"]
    pub fn atanh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_atanhl"]
    pub fn atanhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_coshf"]
    pub fn coshf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_cosh"]
    pub fn cosh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_coshl"]
    pub fn coshl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinhf"]
    pub fn sinhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sinh"]
    pub fn sinh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sinhl"]
    pub fn sinhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanhf"]
    pub fn tanhf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_tanh"]
    pub fn tanh(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tanhl"]
    pub fn tanhl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expf"]
    pub fn expf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_exp"]
    pub fn exp(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expl"]
    pub fn expl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_exp2f"]
    pub fn exp2f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_exp2"]
    pub fn exp2(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_exp2l"]
    pub fn exp2l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expm1f"]
    pub fn expm1f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_expm1"]
    pub fn expm1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_expm1l"]
    pub fn expm1l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logf"]
    pub fn logf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log"]
    pub fn log(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logl"]
    pub fn logl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log10f"]
    pub fn log10f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log10"]
    pub fn log10(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log10l"]
    pub fn log10l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log2f"]
    pub fn log2f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log2"]
    pub fn log2(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log2l"]
    pub fn log2l(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log1pf"]
    pub fn log1pf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_log1p"]
    pub fn log1p(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_log1pl"]
    pub fn log1pl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logbf"]
    pub fn logbf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_logb"]
    pub fn logb(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_logbl"]
    pub fn logbl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_modff"]
    pub fn modff(arg1: f32, arg2: *mut f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_modf"]
    pub fn modf(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_modfl"]
    pub fn modfl(arg1: f64, arg2: *mut f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ldexpf"]
    pub fn ldexpf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ldexp"]
    pub fn ldexp(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ldexpl"]
    pub fn ldexpl(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_frexpf"]
    pub fn frexpf(arg1: f32, arg2: *mut libc::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_frexp"]
    pub fn frexp(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_frexpl"]
    pub fn frexpl(arg1: f64, arg2: *mut libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ilogbf"]
    pub fn ilogbf(arg1: f32) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ilogb"]
    pub fn ilogb(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}_ilogbl"]
    pub fn ilogbl(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}_scalbnf"]
    pub fn scalbnf(arg1: f32, arg2: libc::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_scalbn"]
    pub fn scalbn(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalbnl"]
    pub fn scalbnl(arg1: f64, arg2: libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalblnf"]
    pub fn scalblnf(arg1: f32, arg2: libc::c_long) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_scalbln"]
    pub fn scalbln(arg1: f64, arg2: libc::c_long) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalblnl"]
    pub fn scalblnl(arg1: f64, arg2: libc::c_long) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fabsf"]
    pub fn fabsf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fabs"]
    pub fn fabs(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fabsl"]
    pub fn fabsl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cbrtf"]
    pub fn cbrtf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_cbrt"]
    pub fn cbrt(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_cbrtl"]
    pub fn cbrtl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_hypotf"]
    pub fn hypotf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_hypot"]
    pub fn hypot(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_hypotl"]
    pub fn hypotl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_powf"]
    pub fn powf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_pow"]
    pub fn pow(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_powl"]
    pub fn powl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sqrtf"]
    pub fn sqrtf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_sqrt"]
    pub fn sqrt(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_sqrtl"]
    pub fn sqrtl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erff"]
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_erf"]
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erfl"]
    pub fn erfl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erfcf"]
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_erfc"]
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_erfcl"]
    pub fn erfcl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_lgammaf"]
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_lgamma"]
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_lgammal"]
    pub fn lgammal(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tgammaf"]
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_tgamma"]
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_tgammal"]
    pub fn tgammal(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ceilf"]
    pub fn ceilf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_ceil"]
    pub fn ceil(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_ceill"]
    pub fn ceill(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_floorf"]
    pub fn floorf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_floor"]
    pub fn floor(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_floorl"]
    pub fn floorl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nearbyintf"]
    pub fn nearbyintf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nearbyint"]
    pub fn nearbyint(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nearbyintl"]
    pub fn nearbyintl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_rintf"]
    pub fn rintf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_rint"]
    pub fn rint(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_rintl"]
    pub fn rintl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_lrintf"]
    pub fn lrintf(arg1: f32) -> libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lrint"]
    pub fn lrint(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lrintl"]
    pub fn lrintl(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}_roundf"]
    pub fn roundf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_round"]
    pub fn round(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_roundl"]
    pub fn roundl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_lroundf"]
    pub fn lroundf(arg1: f32) -> libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lround"]
    pub fn lround(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}_lroundl"]
    pub fn lroundl(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}_llrintf"]
    pub fn llrintf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llrint"]
    pub fn llrint(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llrintl"]
    pub fn llrintl(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llroundf"]
    pub fn llroundf(arg1: f32) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llround"]
    pub fn llround(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_llroundl"]
    pub fn llroundl(arg1: f64) -> libc::c_longlong;
}
extern "C" {
    #[link_name = "\u{1}_truncf"]
    pub fn truncf(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_trunc"]
    pub fn trunc(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_truncl"]
    pub fn truncl(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmodf"]
    pub fn fmodf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fmod"]
    pub fn fmod(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmodl"]
    pub fn fmodl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remainderf"]
    pub fn remainderf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_remainder"]
    pub fn remainder(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remainderl"]
    pub fn remainderl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remquof"]
    pub fn remquof(arg1: f32, arg2: f32, arg3: *mut libc::c_int) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_remquo"]
    pub fn remquo(arg1: f64, arg2: f64, arg3: *mut libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_remquol"]
    pub fn remquol(arg1: f64, arg2: f64, arg3: *mut libc::c_int) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_copysignf"]
    pub fn copysignf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_copysign"]
    pub fn copysign(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_copysignl"]
    pub fn copysignl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nanf"]
    pub fn nanf(arg1: *const libc::c_char) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nan"]
    pub fn nan(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nanl"]
    pub fn nanl(arg1: *const libc::c_char) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nextafterf"]
    pub fn nextafterf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nextafter"]
    pub fn nextafter(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nextafterl"]
    pub fn nextafterl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nexttoward"]
    pub fn nexttoward(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_nexttowardf"]
    pub fn nexttowardf(arg1: f32, arg2: f64) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_nexttowardl"]
    pub fn nexttowardl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fdimf"]
    pub fn fdimf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fdim"]
    pub fn fdim(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fdiml"]
    pub fn fdiml(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmaxf"]
    pub fn fmaxf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fmax"]
    pub fn fmax(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmaxl"]
    pub fn fmaxl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fminf"]
    pub fn fminf(arg1: f32, arg2: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fmin"]
    pub fn fmin(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fminl"]
    pub fn fminl(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmaf"]
    pub fn fmaf(arg1: f32, arg2: f32, arg3: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}_fma"]
    pub fn fma(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_fmal"]
    pub fn fmal(arg1: f64, arg2: f64, arg3: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___inff"]
    pub fn __inff() -> f32;
}
extern "C" {
    #[link_name = "\u{1}___inf"]
    pub fn __inf() -> f64;
}
extern "C" {
    #[link_name = "\u{1}___infl"]
    pub fn __infl() -> f64;
}
extern "C" {
    #[link_name = "\u{1}___nan"]
    pub fn __nan() -> f32;
}
extern "C" {
    #[link_name = "\u{1}___exp10f"]
    pub fn __exp10f(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___exp10"]
    pub fn __exp10(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___cospif"]
    pub fn __cospif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___cospi"]
    pub fn __cospi(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___sinpif"]
    pub fn __sinpif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___sinpi"]
    pub fn __sinpi(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}___tanpif"]
    pub fn __tanpif(arg1: f32) -> f32;
}
extern "C" {
    #[link_name = "\u{1}___tanpi"]
    pub fn __tanpi(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __float2 {
    pub __sinval: f32,
    pub __cosval: f32,
}
#[test]
fn bindgen_test_layout___float2() {
    assert_eq!(
        ::core::mem::size_of::<__float2>(),
        8usize,
        concat!("Size of: ", stringify!(__float2))
    );
    assert_eq!(
        ::core::mem::align_of::<__float2>(),
        4usize,
        concat!("Alignment of ", stringify!(__float2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__float2>())).__sinval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__float2>())).__cosval as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__float2),
            "::",
            stringify!(__cosval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __double2 {
    pub __sinval: f64,
    pub __cosval: f64,
}
#[test]
fn bindgen_test_layout___double2() {
    assert_eq!(
        ::core::mem::size_of::<__double2>(),
        16usize,
        concat!("Size of: ", stringify!(__double2))
    );
    assert_eq!(
        ::core::mem::align_of::<__double2>(),
        8usize,
        concat!("Alignment of ", stringify!(__double2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__double2>())).__sinval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__sinval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__double2>())).__cosval as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__double2),
            "::",
            stringify!(__cosval)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}___sincosf_stret"]
    pub fn __sincosf_stret(arg1: f32) -> __float2;
}
extern "C" {
    #[link_name = "\u{1}___sincos_stret"]
    pub fn __sincos_stret(arg1: f64) -> __double2;
}
extern "C" {
    #[link_name = "\u{1}___sincospif_stret"]
    pub fn __sincospif_stret(arg1: f32) -> __float2;
}
extern "C" {
    #[link_name = "\u{1}___sincospi_stret"]
    pub fn __sincospi_stret(arg1: f64) -> __double2;
}
extern "C" {
    #[link_name = "\u{1}_j0"]
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_j1"]
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_jn"]
    pub fn jn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_y0"]
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_y1"]
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_yn"]
    pub fn yn(arg1: libc::c_int, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_scalb"]
    pub fn scalb(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_signgam"]
    pub static mut signgam: libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}_rinttol"]
    pub fn rinttol(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}_roundtol"]
    pub fn roundtol(arg1: f64) -> libc::c_long;
}
extern "C" {
    #[link_name = "\u{1}_drem"]
    pub fn drem(arg1: f64, arg2: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_finite"]
    pub fn finite(arg1: f64) -> libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}_gamma"]
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_significand"]
    pub fn significand(arg1: f64) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct exception {
    pub type_: libc::c_int,
    pub name: *mut libc::c_char,
    pub arg1: f64,
    pub arg2: f64,
    pub retval: f64,
}
#[test]
fn bindgen_test_layout_exception() {
    assert_eq!(
        ::core::mem::size_of::<exception>(),
        40usize,
        concat!("Size of: ", stringify!(exception))
    );
    assert_eq!(
        ::core::mem::align_of::<exception>(),
        8usize,
        concat!("Alignment of ", stringify!(exception))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).arg1 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).arg2 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(arg2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<exception>())).retval as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(exception),
            "::",
            stringify!(retval)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_matherr"]
    pub fn matherr(arg1: *mut exception) -> libc::c_int;
}
pub type Reset = ::core::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void)>;
pub type DelayMs = ::core::option::Option<unsafe extern "C" fn(ctx: *mut libc::c_void, ms: u32)>;
pub type WriteBuffer = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut libc::c_void, addr: u8, buffer: *mut u8, size: u8),
>;
pub type ReadBuffer = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut libc::c_void, addr: u8, buffer: *mut u8, size: u8),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SX1280_s {
    pub ctx: *mut libc::c_void,
    pub reset: Reset,
    pub delay_ms: DelayMs,
    pub write_buffer: WriteBuffer,
    pub read_buffer: ReadBuffer,
}
#[test]
fn bindgen_test_layout_SX1280_s() {
    assert_eq!(
        ::core::mem::size_of::<SX1280_s>(),
        40usize,
        concat!("Size of: ", stringify!(SX1280_s))
    );
    assert_eq!(
        ::core::mem::align_of::<SX1280_s>(),
        8usize,
        concat!("Alignment of ", stringify!(SX1280_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).reset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).delay_ms as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(delay_ms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).write_buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(write_buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<SX1280_s>())).read_buffer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SX1280_s),
            "::",
            stringify!(read_buffer)
        )
    );
}
pub type SX1280_t = SX1280_s;
pub type DioIrqHandler = ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>;
pub const RadioLnaSettings_t_LNA_LOW_POWER_MODE: RadioLnaSettings_t = 0;
pub const RadioLnaSettings_t_LNA_HIGH_SENSITIVITY_MODE: RadioLnaSettings_t = 1;
pub type RadioLnaSettings_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union RadioStatus_t {
    pub Fields: RadioStatus_t__bindgen_ty_1,
    pub Value: u8,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct RadioStatus_t__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_RadioStatus_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RadioStatus_t__bindgen_ty_1>(),
        1usize,
        concat!("Size of: ", stringify!(RadioStatus_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RadioStatus_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(RadioStatus_t__bindgen_ty_1))
    );
}
impl RadioStatus_t__bindgen_ty_1 {
    #[inline]
    pub fn CpuBusy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CpuBusy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DmaBusy(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DmaBusy(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CmdStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_CmdStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn ChipMode(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_ChipMode(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CpuBusy: u8,
        DmaBusy: u8,
        CmdStatus: u8,
        ChipMode: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CpuBusy: u8 = unsafe { ::core::mem::transmute(CpuBusy) };
            CpuBusy as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DmaBusy: u8 = unsafe { ::core::mem::transmute(DmaBusy) };
            DmaBusy as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let CmdStatus: u8 = unsafe { ::core::mem::transmute(CmdStatus) };
            CmdStatus as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let ChipMode: u8 = unsafe { ::core::mem::transmute(ChipMode) };
            ChipMode as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_RadioStatus_t() {
    assert_eq!(
        ::core::mem::size_of::<RadioStatus_t>(),
        1usize,
        concat!("Size of: ", stringify!(RadioStatus_t))
    );
    assert_eq!(
        ::core::mem::align_of::<RadioStatus_t>(),
        1usize,
        concat!("Alignment of ", stringify!(RadioStatus_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioStatus_t>())).Fields as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioStatus_t),
            "::",
            stringify!(Fields)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioStatus_t>())).Value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioStatus_t),
            "::",
            stringify!(Value)
        )
    );
}
pub const RadioStates_t_RF_IDLE: RadioStates_t = 0;
pub const RadioStates_t_RF_RX_RUNNING: RadioStates_t = 1;
pub const RadioStates_t_RF_TX_RUNNING: RadioStates_t = 2;
pub const RadioStates_t_RF_CAD: RadioStates_t = 3;
pub type RadioStates_t = u32;
pub const RadioOperatingModes_t_MODE_SLEEP: RadioOperatingModes_t = 0;
pub const RadioOperatingModes_t_MODE_STDBY_RC: RadioOperatingModes_t = 1;
pub const RadioOperatingModes_t_MODE_STDBY_XOSC: RadioOperatingModes_t = 2;
pub const RadioOperatingModes_t_MODE_FS: RadioOperatingModes_t = 3;
pub const RadioOperatingModes_t_MODE_TX: RadioOperatingModes_t = 4;
pub const RadioOperatingModes_t_MODE_RX: RadioOperatingModes_t = 5;
pub const RadioOperatingModes_t_MODE_CAD: RadioOperatingModes_t = 6;
pub type RadioOperatingModes_t = u32;
pub const RadioStandbyModes_t_STDBY_RC: RadioStandbyModes_t = 0;
pub const RadioStandbyModes_t_STDBY_XOSC: RadioStandbyModes_t = 1;
pub type RadioStandbyModes_t = u32;
pub const RadioRegulatorModes_t_USE_LDO: RadioRegulatorModes_t = 0;
pub const RadioRegulatorModes_t_USE_DCDC: RadioRegulatorModes_t = 1;
pub type RadioRegulatorModes_t = u32;
pub const RadioPacketTypes_t_PACKET_TYPE_GFSK: RadioPacketTypes_t = 0;
pub const RadioPacketTypes_t_PACKET_TYPE_LORA: RadioPacketTypes_t = 1;
pub const RadioPacketTypes_t_PACKET_TYPE_RANGING: RadioPacketTypes_t = 2;
pub const RadioPacketTypes_t_PACKET_TYPE_FLRC: RadioPacketTypes_t = 3;
pub const RadioPacketTypes_t_PACKET_TYPE_BLE: RadioPacketTypes_t = 4;
pub const RadioPacketTypes_t_PACKET_TYPE_NONE: RadioPacketTypes_t = 15;
pub type RadioPacketTypes_t = u32;
pub const RadioRampTimes_t_RADIO_RAMP_02_US: RadioRampTimes_t = 0;
pub const RadioRampTimes_t_RADIO_RAMP_04_US: RadioRampTimes_t = 32;
pub const RadioRampTimes_t_RADIO_RAMP_06_US: RadioRampTimes_t = 64;
pub const RadioRampTimes_t_RADIO_RAMP_08_US: RadioRampTimes_t = 96;
pub const RadioRampTimes_t_RADIO_RAMP_10_US: RadioRampTimes_t = 128;
pub const RadioRampTimes_t_RADIO_RAMP_12_US: RadioRampTimes_t = 160;
pub const RadioRampTimes_t_RADIO_RAMP_16_US: RadioRampTimes_t = 192;
pub const RadioRampTimes_t_RADIO_RAMP_20_US: RadioRampTimes_t = 224;
pub type RadioRampTimes_t = u32;
pub const RadioLoRaCadSymbols_t_LORA_CAD_01_SYMBOL: RadioLoRaCadSymbols_t = 0;
pub const RadioLoRaCadSymbols_t_LORA_CAD_02_SYMBOL: RadioLoRaCadSymbols_t = 32;
pub const RadioLoRaCadSymbols_t_LORA_CAD_04_SYMBOL: RadioLoRaCadSymbols_t = 64;
pub const RadioLoRaCadSymbols_t_LORA_CAD_08_SYMBOL: RadioLoRaCadSymbols_t = 96;
pub const RadioLoRaCadSymbols_t_LORA_CAD_16_SYMBOL: RadioLoRaCadSymbols_t = 128;
pub type RadioLoRaCadSymbols_t = u32;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_2_000_BW_2_4: RadioGfskBleBitrates_t = 4;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_1_600_BW_2_4: RadioGfskBleBitrates_t = 40;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_1_000_BW_2_4: RadioGfskBleBitrates_t = 76;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_1_000_BW_1_2: RadioGfskBleBitrates_t = 69;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_800_BW_2_4: RadioGfskBleBitrates_t = 112;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_800_BW_1_2: RadioGfskBleBitrates_t = 105;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_500_BW_1_2: RadioGfskBleBitrates_t = 141;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_500_BW_0_6: RadioGfskBleBitrates_t = 134;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_400_BW_1_2: RadioGfskBleBitrates_t = 177;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_400_BW_0_6: RadioGfskBleBitrates_t = 170;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_250_BW_0_6: RadioGfskBleBitrates_t = 206;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_250_BW_0_3: RadioGfskBleBitrates_t = 199;
pub const RadioGfskBleBitrates_t_GFSK_BLE_BR_0_125_BW_0_3: RadioGfskBleBitrates_t = 239;
pub type RadioGfskBleBitrates_t = u32;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_0_35: RadioGfskBleModIndexes_t = 0;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_0_50: RadioGfskBleModIndexes_t = 1;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_0_75: RadioGfskBleModIndexes_t = 2;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_1_00: RadioGfskBleModIndexes_t = 3;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_1_25: RadioGfskBleModIndexes_t = 4;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_1_50: RadioGfskBleModIndexes_t = 5;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_1_75: RadioGfskBleModIndexes_t = 6;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_2_00: RadioGfskBleModIndexes_t = 7;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_2_25: RadioGfskBleModIndexes_t = 8;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_2_50: RadioGfskBleModIndexes_t = 9;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_2_75: RadioGfskBleModIndexes_t = 10;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_3_00: RadioGfskBleModIndexes_t = 11;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_3_25: RadioGfskBleModIndexes_t = 12;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_3_50: RadioGfskBleModIndexes_t = 13;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_3_75: RadioGfskBleModIndexes_t = 14;
pub const RadioGfskBleModIndexes_t_GFSK_BLE_MOD_IND_4_00: RadioGfskBleModIndexes_t = 15;
pub type RadioGfskBleModIndexes_t = u32;
pub const RadioFlrcBitrates_t_FLRC_BR_2_600_BW_2_4: RadioFlrcBitrates_t = 4;
pub const RadioFlrcBitrates_t_FLRC_BR_2_080_BW_2_4: RadioFlrcBitrates_t = 40;
pub const RadioFlrcBitrates_t_FLRC_BR_1_300_BW_1_2: RadioFlrcBitrates_t = 69;
pub const RadioFlrcBitrates_t_FLRC_BR_1_040_BW_1_2: RadioFlrcBitrates_t = 105;
pub const RadioFlrcBitrates_t_FLRC_BR_0_650_BW_0_6: RadioFlrcBitrates_t = 134;
pub const RadioFlrcBitrates_t_FLRC_BR_0_520_BW_0_6: RadioFlrcBitrates_t = 170;
pub const RadioFlrcBitrates_t_FLRC_BR_0_325_BW_0_3: RadioFlrcBitrates_t = 199;
pub const RadioFlrcBitrates_t_FLRC_BR_0_260_BW_0_3: RadioFlrcBitrates_t = 235;
pub type RadioFlrcBitrates_t = u32;
pub const RadioFlrcCodingRates_t_FLRC_CR_1_2: RadioFlrcCodingRates_t = 0;
pub const RadioFlrcCodingRates_t_FLRC_CR_3_4: RadioFlrcCodingRates_t = 2;
pub const RadioFlrcCodingRates_t_FLRC_CR_1_0: RadioFlrcCodingRates_t = 4;
pub type RadioFlrcCodingRates_t = u32;
pub const RadioModShapings_t_RADIO_MOD_SHAPING_BT_OFF: RadioModShapings_t = 0;
pub const RadioModShapings_t_RADIO_MOD_SHAPING_BT_1_0: RadioModShapings_t = 16;
pub const RadioModShapings_t_RADIO_MOD_SHAPING_BT_0_5: RadioModShapings_t = 32;
pub type RadioModShapings_t = u32;
pub const RadioLoRaSpreadingFactors_t_LORA_SF5: RadioLoRaSpreadingFactors_t = 80;
pub const RadioLoRaSpreadingFactors_t_LORA_SF6: RadioLoRaSpreadingFactors_t = 96;
pub const RadioLoRaSpreadingFactors_t_LORA_SF7: RadioLoRaSpreadingFactors_t = 112;
pub const RadioLoRaSpreadingFactors_t_LORA_SF8: RadioLoRaSpreadingFactors_t = 128;
pub const RadioLoRaSpreadingFactors_t_LORA_SF9: RadioLoRaSpreadingFactors_t = 144;
pub const RadioLoRaSpreadingFactors_t_LORA_SF10: RadioLoRaSpreadingFactors_t = 160;
pub const RadioLoRaSpreadingFactors_t_LORA_SF11: RadioLoRaSpreadingFactors_t = 176;
pub const RadioLoRaSpreadingFactors_t_LORA_SF12: RadioLoRaSpreadingFactors_t = 192;
pub type RadioLoRaSpreadingFactors_t = u32;
pub const RadioLoRaBandwidths_t_LORA_BW_0200: RadioLoRaBandwidths_t = 52;
pub const RadioLoRaBandwidths_t_LORA_BW_0400: RadioLoRaBandwidths_t = 38;
pub const RadioLoRaBandwidths_t_LORA_BW_0800: RadioLoRaBandwidths_t = 24;
pub const RadioLoRaBandwidths_t_LORA_BW_1600: RadioLoRaBandwidths_t = 10;
pub type RadioLoRaBandwidths_t = u32;
pub const RadioLoRaCodingRates_t_LORA_CR_4_5: RadioLoRaCodingRates_t = 1;
pub const RadioLoRaCodingRates_t_LORA_CR_4_6: RadioLoRaCodingRates_t = 2;
pub const RadioLoRaCodingRates_t_LORA_CR_4_7: RadioLoRaCodingRates_t = 3;
pub const RadioLoRaCodingRates_t_LORA_CR_4_8: RadioLoRaCodingRates_t = 4;
pub const RadioLoRaCodingRates_t_LORA_CR_LI_4_5: RadioLoRaCodingRates_t = 5;
pub const RadioLoRaCodingRates_t_LORA_CR_LI_4_6: RadioLoRaCodingRates_t = 6;
pub const RadioLoRaCodingRates_t_LORA_CR_LI_4_7: RadioLoRaCodingRates_t = 7;
pub type RadioLoRaCodingRates_t = u32;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_04_BITS: RadioPreambleLengths_t = 0;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_08_BITS: RadioPreambleLengths_t = 16;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_12_BITS: RadioPreambleLengths_t = 32;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_16_BITS: RadioPreambleLengths_t = 48;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_20_BITS: RadioPreambleLengths_t = 64;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_24_BITS: RadioPreambleLengths_t = 80;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_28_BITS: RadioPreambleLengths_t = 96;
pub const RadioPreambleLengths_t_PREAMBLE_LENGTH_32_BITS: RadioPreambleLengths_t = 112;
pub type RadioPreambleLengths_t = u32;
pub const RadioFlrcSyncWordLengths_t_FLRC_NO_SYNCWORD: RadioFlrcSyncWordLengths_t = 0;
pub const RadioFlrcSyncWordLengths_t_FLRC_SYNCWORD_LENGTH_4_BYTE: RadioFlrcSyncWordLengths_t = 4;
pub type RadioFlrcSyncWordLengths_t = u32;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_1_BYTE: RadioSyncWordLengths_t = 0;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_2_BYTE: RadioSyncWordLengths_t = 2;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_3_BYTE: RadioSyncWordLengths_t = 4;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_4_BYTE: RadioSyncWordLengths_t = 6;
pub const RadioSyncWordLengths_t_GFSK_SYNCWORD_LENGTH_5_BYTE: RadioSyncWordLengths_t = 8;
pub type RadioSyncWordLengths_t = u32;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_OFF: RadioSyncWordRxMatchs_t = 0;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_1: RadioSyncWordRxMatchs_t = 16;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_2: RadioSyncWordRxMatchs_t = 32;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_1_2: RadioSyncWordRxMatchs_t = 48;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_3: RadioSyncWordRxMatchs_t = 64;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_1_3: RadioSyncWordRxMatchs_t = 80;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_2_3: RadioSyncWordRxMatchs_t = 96;
pub const RadioSyncWordRxMatchs_t_RADIO_RX_MATCH_SYNCWORD_1_2_3: RadioSyncWordRxMatchs_t = 112;
pub type RadioSyncWordRxMatchs_t = u32;
pub const RadioPacketLengthModes_t_RADIO_PACKET_FIXED_LENGTH: RadioPacketLengthModes_t = 0;
pub const RadioPacketLengthModes_t_RADIO_PACKET_VARIABLE_LENGTH: RadioPacketLengthModes_t = 32;
pub type RadioPacketLengthModes_t = u32;
pub const RadioCrcTypes_t_RADIO_CRC_OFF: RadioCrcTypes_t = 0;
pub const RadioCrcTypes_t_RADIO_CRC_1_BYTES: RadioCrcTypes_t = 16;
pub const RadioCrcTypes_t_RADIO_CRC_2_BYTES: RadioCrcTypes_t = 32;
pub const RadioCrcTypes_t_RADIO_CRC_3_BYTES: RadioCrcTypes_t = 48;
pub type RadioCrcTypes_t = u32;
pub const RadioWhiteningModes_t_RADIO_WHITENING_ON: RadioWhiteningModes_t = 0;
pub const RadioWhiteningModes_t_RADIO_WHITENING_OFF: RadioWhiteningModes_t = 8;
pub type RadioWhiteningModes_t = u32;
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_VARIABLE_LENGTH: RadioLoRaPacketLengthsModes_t =
    0;
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_FIXED_LENGTH: RadioLoRaPacketLengthsModes_t =
    128;
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_EXPLICIT: RadioLoRaPacketLengthsModes_t = 0;
pub const RadioLoRaPacketLengthsModes_t_LORA_PACKET_IMPLICIT: RadioLoRaPacketLengthsModes_t = 128;
pub type RadioLoRaPacketLengthsModes_t = u32;
pub const RadioLoRaCrcModes_t_LORA_CRC_ON: RadioLoRaCrcModes_t = 32;
pub const RadioLoRaCrcModes_t_LORA_CRC_OFF: RadioLoRaCrcModes_t = 0;
pub type RadioLoRaCrcModes_t = u32;
pub const RadioLoRaIQModes_t_LORA_IQ_NORMAL: RadioLoRaIQModes_t = 64;
pub const RadioLoRaIQModes_t_LORA_IQ_INVERTED: RadioLoRaIQModes_t = 0;
pub type RadioLoRaIQModes_t = u32;
pub const RadioRangingIdCheckLengths_t_RANGING_IDCHECK_LENGTH_08_BITS:
    RadioRangingIdCheckLengths_t = 0;
pub const RadioRangingIdCheckLengths_t_RANGING_IDCHECK_LENGTH_16_BITS:
    RadioRangingIdCheckLengths_t = 1;
pub const RadioRangingIdCheckLengths_t_RANGING_IDCHECK_LENGTH_24_BITS:
    RadioRangingIdCheckLengths_t = 2;
pub const RadioRangingIdCheckLengths_t_RANGING_IDCHECK_LENGTH_32_BITS:
    RadioRangingIdCheckLengths_t = 3;
pub type RadioRangingIdCheckLengths_t = u32;
pub const RadioRangingResultTypes_t_RANGING_RESULT_RAW: RadioRangingResultTypes_t = 0;
pub const RadioRangingResultTypes_t_RANGING_RESULT_AVERAGED: RadioRangingResultTypes_t = 1;
pub const RadioRangingResultTypes_t_RANGING_RESULT_DEBIASED: RadioRangingResultTypes_t = 2;
pub const RadioRangingResultTypes_t_RANGING_RESULT_FILTERED: RadioRangingResultTypes_t = 3;
pub type RadioRangingResultTypes_t = u32;
pub const RadioBleConnectionStates_t_BLE_PAYLOAD_LENGTH_MAX_31_BYTES: RadioBleConnectionStates_t =
    0;
pub const RadioBleConnectionStates_t_BLE_PAYLOAD_LENGTH_MAX_37_BYTES: RadioBleConnectionStates_t =
    32;
pub const RadioBleConnectionStates_t_BLE_TX_TEST_MODE: RadioBleConnectionStates_t = 64;
pub const RadioBleConnectionStates_t_BLE_PAYLOAD_LENGTH_MAX_255_BYTES: RadioBleConnectionStates_t =
    128;
pub type RadioBleConnectionStates_t = u32;
pub const RadioBleCrcFields_t_BLE_CRC_OFF: RadioBleCrcFields_t = 0;
pub const RadioBleCrcFields_t_BLE_CRC_3B: RadioBleCrcFields_t = 16;
pub type RadioBleCrcFields_t = u32;
pub const RadioBlePacketTypes_t_BLE_PRBS_9: RadioBlePacketTypes_t = 0;
pub const RadioBlePacketTypes_t_BLE_PRBS_15: RadioBlePacketTypes_t = 12;
pub const RadioBlePacketTypes_t_BLE_EYELONG_1_0: RadioBlePacketTypes_t = 4;
pub const RadioBlePacketTypes_t_BLE_EYELONG_0_1: RadioBlePacketTypes_t = 24;
pub const RadioBlePacketTypes_t_BLE_EYESHORT_1_0: RadioBlePacketTypes_t = 8;
pub const RadioBlePacketTypes_t_BLE_EYESHORT_0_1: RadioBlePacketTypes_t = 28;
pub const RadioBlePacketTypes_t_BLE_ALL_1: RadioBlePacketTypes_t = 16;
pub const RadioBlePacketTypes_t_BLE_ALL_0: RadioBlePacketTypes_t = 20;
pub type RadioBlePacketTypes_t = u32;
pub const RadioIrqMasks_t_IRQ_RADIO_NONE: RadioIrqMasks_t = 0;
pub const RadioIrqMasks_t_IRQ_TX_DONE: RadioIrqMasks_t = 1;
pub const RadioIrqMasks_t_IRQ_RX_DONE: RadioIrqMasks_t = 2;
pub const RadioIrqMasks_t_IRQ_SYNCWORD_VALID: RadioIrqMasks_t = 4;
pub const RadioIrqMasks_t_IRQ_SYNCWORD_ERROR: RadioIrqMasks_t = 8;
pub const RadioIrqMasks_t_IRQ_HEADER_VALID: RadioIrqMasks_t = 16;
pub const RadioIrqMasks_t_IRQ_HEADER_ERROR: RadioIrqMasks_t = 32;
pub const RadioIrqMasks_t_IRQ_CRC_ERROR: RadioIrqMasks_t = 64;
pub const RadioIrqMasks_t_IRQ_RANGING_SLAVE_RESPONSE_DONE: RadioIrqMasks_t = 128;
pub const RadioIrqMasks_t_IRQ_RANGING_SLAVE_REQUEST_DISCARDED: RadioIrqMasks_t = 256;
pub const RadioIrqMasks_t_IRQ_RANGING_MASTER_RESULT_VALID: RadioIrqMasks_t = 512;
pub const RadioIrqMasks_t_IRQ_RANGING_MASTER_RESULT_TIMEOUT: RadioIrqMasks_t = 1024;
pub const RadioIrqMasks_t_IRQ_RANGING_SLAVE_REQUEST_VALID: RadioIrqMasks_t = 2048;
pub const RadioIrqMasks_t_IRQ_CAD_DONE: RadioIrqMasks_t = 4096;
pub const RadioIrqMasks_t_IRQ_CAD_ACTIVITY_DETECTED: RadioIrqMasks_t = 8192;
pub const RadioIrqMasks_t_IRQ_RX_TX_TIMEOUT: RadioIrqMasks_t = 16384;
pub const RadioIrqMasks_t_IRQ_PREAMBLE_DETECTED: RadioIrqMasks_t = 32768;
pub const RadioIrqMasks_t_IRQ_RADIO_ALL: RadioIrqMasks_t = 65535;
pub type RadioIrqMasks_t = u32;
pub const RadioDios_t_RADIO_DIO1: RadioDios_t = 2;
pub const RadioDios_t_RADIO_DIO2: RadioDios_t = 4;
pub const RadioDios_t_RADIO_DIO3: RadioDios_t = 8;
pub type RadioDios_t = u32;
pub const RadioTickSizes_t_RADIO_TICK_SIZE_0015_US: RadioTickSizes_t = 0;
pub const RadioTickSizes_t_RADIO_TICK_SIZE_0062_US: RadioTickSizes_t = 1;
pub const RadioTickSizes_t_RADIO_TICK_SIZE_1000_US: RadioTickSizes_t = 2;
pub const RadioTickSizes_t_RADIO_TICK_SIZE_4000_US: RadioTickSizes_t = 3;
pub type RadioTickSizes_t = u32;
pub const RadioRangingRoles_t_RADIO_RANGING_ROLE_SLAVE: RadioRangingRoles_t = 0;
pub const RadioRangingRoles_t_RADIO_RANGING_ROLE_MASTER: RadioRangingRoles_t = 1;
pub type RadioRangingRoles_t = u32;
pub const RadioCommands_u_RADIO_GET_STATUS: RadioCommands_u = 192;
pub const RadioCommands_u_RADIO_WRITE_REGISTER: RadioCommands_u = 24;
pub const RadioCommands_u_RADIO_READ_REGISTER: RadioCommands_u = 25;
pub const RadioCommands_u_RADIO_WRITE_BUFFER: RadioCommands_u = 26;
pub const RadioCommands_u_RADIO_READ_BUFFER: RadioCommands_u = 27;
pub const RadioCommands_u_RADIO_SET_SLEEP: RadioCommands_u = 132;
pub const RadioCommands_u_RADIO_SET_STANDBY: RadioCommands_u = 128;
pub const RadioCommands_u_RADIO_SET_FS: RadioCommands_u = 193;
pub const RadioCommands_u_RADIO_SET_TX: RadioCommands_u = 131;
pub const RadioCommands_u_RADIO_SET_RX: RadioCommands_u = 130;
pub const RadioCommands_u_RADIO_SET_RXDUTYCYCLE: RadioCommands_u = 148;
pub const RadioCommands_u_RADIO_SET_CAD: RadioCommands_u = 197;
pub const RadioCommands_u_RADIO_SET_TXCONTINUOUSWAVE: RadioCommands_u = 209;
pub const RadioCommands_u_RADIO_SET_TXCONTINUOUSPREAMBLE: RadioCommands_u = 210;
pub const RadioCommands_u_RADIO_SET_PACKETTYPE: RadioCommands_u = 138;
pub const RadioCommands_u_RADIO_GET_PACKETTYPE: RadioCommands_u = 3;
pub const RadioCommands_u_RADIO_SET_RFFREQUENCY: RadioCommands_u = 134;
pub const RadioCommands_u_RADIO_SET_TXPARAMS: RadioCommands_u = 142;
pub const RadioCommands_u_RADIO_SET_CADPARAMS: RadioCommands_u = 136;
pub const RadioCommands_u_RADIO_SET_BUFFERBASEADDRESS: RadioCommands_u = 143;
pub const RadioCommands_u_RADIO_SET_MODULATIONPARAMS: RadioCommands_u = 139;
pub const RadioCommands_u_RADIO_SET_PACKETPARAMS: RadioCommands_u = 140;
pub const RadioCommands_u_RADIO_GET_RXBUFFERSTATUS: RadioCommands_u = 23;
pub const RadioCommands_u_RADIO_GET_PACKETSTATUS: RadioCommands_u = 29;
pub const RadioCommands_u_RADIO_GET_RSSIINST: RadioCommands_u = 31;
pub const RadioCommands_u_RADIO_SET_DIOIRQPARAMS: RadioCommands_u = 141;
pub const RadioCommands_u_RADIO_GET_IRQSTATUS: RadioCommands_u = 21;
pub const RadioCommands_u_RADIO_CLR_IRQSTATUS: RadioCommands_u = 151;
pub const RadioCommands_u_RADIO_CALIBRATE: RadioCommands_u = 137;
pub const RadioCommands_u_RADIO_SET_REGULATORMODE: RadioCommands_u = 150;
pub const RadioCommands_u_RADIO_SET_SAVECONTEXT: RadioCommands_u = 213;
pub const RadioCommands_u_RADIO_SET_AUTOTX: RadioCommands_u = 152;
pub const RadioCommands_u_RADIO_SET_AUTOFS: RadioCommands_u = 158;
pub const RadioCommands_u_RADIO_SET_LONGPREAMBLE: RadioCommands_u = 155;
pub const RadioCommands_u_RADIO_SET_UARTSPEED: RadioCommands_u = 157;
pub const RadioCommands_u_RADIO_SET_RANGING_ROLE: RadioCommands_u = 163;
pub type RadioCommands_u = u32;
pub use self::RadioCommands_u as RadioCommands_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TickTime_s {
    pub Step: RadioTickSizes_t,
    pub NbSteps: u16,
}
#[test]
fn bindgen_test_layout_TickTime_s() {
    assert_eq!(
        ::core::mem::size_of::<TickTime_s>(),
        8usize,
        concat!("Size of: ", stringify!(TickTime_s))
    );
    assert_eq!(
        ::core::mem::align_of::<TickTime_s>(),
        4usize,
        concat!("Alignment of ", stringify!(TickTime_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TickTime_s>())).Step as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TickTime_s),
            "::",
            stringify!(Step)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<TickTime_s>())).NbSteps as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TickTime_s),
            "::",
            stringify!(NbSteps)
        )
    );
}
pub type TickTime_t = TickTime_s;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t {
    pub PacketType: RadioPacketTypes_t,
    pub Params: ModulationParams_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1 {
    pub Gfsk: ModulationParams_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: ModulationParams_t__bindgen_ty_1__bindgen_ty_2,
    pub Flrc: ModulationParams_t__bindgen_ty_1__bindgen_ty_3,
    pub Ble: ModulationParams_t__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_1 {
    pub BitrateBandwidth: RadioGfskBleBitrates_t,
    pub ModulationIndex: RadioGfskBleModIndexes_t,
    pub ModulationShaping: RadioModShapings_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>()))
                .BitrateBandwidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BitrateBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>()))
                .ModulationIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ModulationIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_1>()))
                .ModulationShaping as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ModulationShaping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_2 {
    pub SpreadingFactor: RadioLoRaSpreadingFactors_t,
    pub Bandwidth: RadioLoRaBandwidths_t,
    pub CodingRate: RadioLoRaCodingRates_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>()))
                .SpreadingFactor as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SpreadingFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>())).Bandwidth
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Bandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_2>())).CodingRate
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(CodingRate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_3 {
    pub BitrateBandwidth: RadioFlrcBitrates_t,
    pub CodingRate: RadioFlrcCodingRates_t,
    pub ModulationShaping: RadioModShapings_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>()))
                .BitrateBandwidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(BitrateBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>())).CodingRate
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(CodingRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_3>()))
                .ModulationShaping as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ModulationShaping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ModulationParams_t__bindgen_ty_1__bindgen_ty_4 {
    pub BitrateBandwidth: RadioGfskBleBitrates_t,
    pub ModulationIndex: RadioGfskBleModIndexes_t,
    pub ModulationShaping: RadioModShapings_t,
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>()))
                .BitrateBandwidth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(BitrateBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>()))
                .ModulationIndex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ModulationIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1__bindgen_ty_4>()))
                .ModulationShaping as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ModulationShaping)
        )
    );
}
#[test]
fn bindgen_test_layout_ModulationParams_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(ModulationParams_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ModulationParams_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1>())).Gfsk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1),
            "::",
            stringify!(Gfsk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1>())).LoRa as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1),
            "::",
            stringify!(LoRa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1>())).Flrc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1),
            "::",
            stringify!(Flrc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ModulationParams_t__bindgen_ty_1>())).Ble as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t__bindgen_ty_1),
            "::",
            stringify!(Ble)
        )
    );
}
#[test]
fn bindgen_test_layout_ModulationParams_t() {
    assert_eq!(
        ::core::mem::size_of::<ModulationParams_t>(),
        52usize,
        concat!("Size of: ", stringify!(ModulationParams_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ModulationParams_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ModulationParams_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ModulationParams_t>())).PacketType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t),
            "::",
            stringify!(PacketType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ModulationParams_t>())).Params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ModulationParams_t),
            "::",
            stringify!(Params)
        )
    );
}
pub const IrqErrorCode_t_IRQ_HEADER_ERROR_CODE: IrqErrorCode_t = 0;
pub const IrqErrorCode_t_IRQ_SYNCWORD_ERROR_CODE: IrqErrorCode_t = 1;
pub const IrqErrorCode_t_IRQ_CRC_ERROR_CODE: IrqErrorCode_t = 2;
pub const IrqErrorCode_t_IRQ_RANGING_ON_LORA_ERROR_CODE: IrqErrorCode_t = 3;
pub type IrqErrorCode_t = u32;
pub const IrqRangingCode_t_IRQ_RANGING_SLAVE_ERROR_CODE: IrqRangingCode_t = 0;
pub const IrqRangingCode_t_IRQ_RANGING_SLAVE_VALID_CODE: IrqRangingCode_t = 1;
pub const IrqRangingCode_t_IRQ_RANGING_MASTER_ERROR_CODE: IrqRangingCode_t = 2;
pub const IrqRangingCode_t_IRQ_RANGING_MASTER_VALID_CODE: IrqRangingCode_t = 3;
pub type IrqRangingCode_t = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RadioCallbacks_t {
    pub txDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxSyncWordDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxHeaderDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub txTimeout: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxTimeout: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t)>,
    pub rxError: ::core::option::Option<
        unsafe extern "C" fn(sx1280: *mut SX1280_t, errCode: IrqErrorCode_t),
    >,
    pub rangingDone:
        ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t, val: IrqRangingCode_t)>,
    pub cadDone: ::core::option::Option<unsafe extern "C" fn(sx1280: *mut SX1280_t, cadFlag: bool)>,
}
#[test]
fn bindgen_test_layout_RadioCallbacks_t() {
    assert_eq!(
        ::core::mem::size_of::<RadioCallbacks_t>(),
        72usize,
        concat!("Size of: ", stringify!(RadioCallbacks_t))
    );
    assert_eq!(
        ::core::mem::align_of::<RadioCallbacks_t>(),
        8usize,
        concat!("Alignment of ", stringify!(RadioCallbacks_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).txDone as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(txDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rxDone as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxDone)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RadioCallbacks_t>())).rxSyncWordDone as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxSyncWordDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rxHeaderDone as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxHeaderDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).txTimeout as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(txTimeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rxTimeout as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxTimeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rxError as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rxError)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).rangingDone as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(rangingDone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RadioCallbacks_t>())).cadDone as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(RadioCallbacks_t),
            "::",
            stringify!(cadDone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t {
    pub PacketType: RadioPacketTypes_t,
    pub Params: PacketParams_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1 {
    pub Gfsk: PacketParams_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: PacketParams_t__bindgen_ty_1__bindgen_ty_2,
    pub Flrc: PacketParams_t__bindgen_ty_1__bindgen_ty_3,
    pub Ble: PacketParams_t__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_1 {
    pub PreambleLength: RadioPreambleLengths_t,
    pub SyncWordLength: RadioSyncWordLengths_t,
    pub SyncWordMatch: RadioSyncWordRxMatchs_t,
    pub HeaderType: RadioPacketLengthModes_t,
    pub PayloadLength: u8,
    pub CrcLength: RadioCrcTypes_t,
    pub Whitening: RadioWhiteningModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).PreambleLength
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(PreambleLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).SyncWordLength
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SyncWordLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).SyncWordMatch
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SyncWordMatch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).HeaderType
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(HeaderType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).PayloadLength
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(PayloadLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).CrcLength
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(CrcLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_1>())).Whitening
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Whitening)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_2 {
    pub PreambleLength: u8,
    pub HeaderType: RadioLoRaPacketLengthsModes_t,
    pub PayloadLength: u8,
    pub CrcMode: RadioLoRaCrcModes_t,
    pub InvertIQ: RadioLoRaIQModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).PreambleLength
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(PreambleLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).HeaderType
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(HeaderType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).PayloadLength
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(PayloadLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).CrcMode
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(CrcMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_2>())).InvertIQ
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(InvertIQ)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_3 {
    pub PreambleLength: RadioPreambleLengths_t,
    pub SyncWordLength: RadioFlrcSyncWordLengths_t,
    pub SyncWordMatch: RadioSyncWordRxMatchs_t,
    pub HeaderType: RadioPacketLengthModes_t,
    pub PayloadLength: u8,
    pub CrcLength: RadioCrcTypes_t,
    pub Whitening: RadioWhiteningModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).PreambleLength
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(PreambleLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).SyncWordLength
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(SyncWordLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).SyncWordMatch
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(SyncWordMatch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).HeaderType
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(HeaderType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).PayloadLength
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(PayloadLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).CrcLength
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(CrcLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_3>())).Whitening
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(Whitening)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketParams_t__bindgen_ty_1__bindgen_ty_4 {
    pub ConnectionState: RadioBleConnectionStates_t,
    pub CrcField: RadioBleCrcFields_t,
    pub BlePacketType: RadioBlePacketTypes_t,
    pub Whitening: RadioWhiteningModes_t,
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>())).ConnectionState
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ConnectionState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>())).CrcField
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(CrcField)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>())).BlePacketType
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(BlePacketType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1__bindgen_ty_4>())).Whitening
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(Whitening)
        )
    );
}
#[test]
fn bindgen_test_layout_PacketParams_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t__bindgen_ty_1>(),
        92usize,
        concat!("Size of: ", stringify!(PacketParams_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(PacketParams_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1>())).Gfsk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1),
            "::",
            stringify!(Gfsk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1>())).LoRa as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1),
            "::",
            stringify!(LoRa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1>())).Flrc as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1),
            "::",
            stringify!(Flrc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketParams_t__bindgen_ty_1>())).Ble as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t__bindgen_ty_1),
            "::",
            stringify!(Ble)
        )
    );
}
#[test]
fn bindgen_test_layout_PacketParams_t() {
    assert_eq!(
        ::core::mem::size_of::<PacketParams_t>(),
        96usize,
        concat!("Size of: ", stringify!(PacketParams_t))
    );
    assert_eq!(
        ::core::mem::align_of::<PacketParams_t>(),
        4usize,
        concat!("Alignment of ", stringify!(PacketParams_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PacketParams_t>())).PacketType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t),
            "::",
            stringify!(PacketType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PacketParams_t>())).Params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketParams_t),
            "::",
            stringify!(Params)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PacketStatus_t {
    pub packetType: RadioPacketTypes_t,
    pub Params: PacketStatus_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PacketStatus_t__bindgen_ty_1 {
    pub Gfsk: PacketStatus_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: PacketStatus_t__bindgen_ty_1__bindgen_ty_2,
    pub Flrc: PacketStatus_t__bindgen_ty_1__bindgen_ty_3,
    pub Ble: PacketStatus_t__bindgen_ty_1__bindgen_ty_4,
    _bindgen_union_align: [u8; 5usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_1 {
    pub RssiAvg: i8,
    pub RssiSync: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncError: bool,
        LengthError: bool,
        CrcError: bool,
        AbortError: bool,
        HeaderReceived: bool,
        PacketReceived: bool,
        PacketControlerBusy: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncError: u8 = unsafe { ::core::mem::transmute(SyncError) };
            SyncError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LengthError: u8 = unsafe { ::core::mem::transmute(LengthError) };
            LengthError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CrcError: u8 = unsafe { ::core::mem::transmute(CrcError) };
            CrcError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AbortError: u8 = unsafe { ::core::mem::transmute(AbortError) };
            AbortError as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HeaderReceived: u8 = unsafe { ::core::mem::transmute(HeaderReceived) };
            HeaderReceived as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PacketReceived: u8 = unsafe { ::core::mem::transmute(PacketReceived) };
            PacketReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PacketControlerBusy: u8 = unsafe { ::core::mem::transmute(PacketControlerBusy) };
            PacketControlerBusy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn RxNoAck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RxNoAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketSent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RxNoAck: bool,
        PacketSent: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RxNoAck: u8 = unsafe { ::core::mem::transmute(RxNoAck) };
            RxNoAck as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PacketSent: u8 = unsafe { ::core::mem::transmute(PacketSent) };
            PacketSent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>())).RssiAvg
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(RssiAvg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>())).RssiSync
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(RssiSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>())).ErrorStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ErrorStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_1>())).TxRxStatus
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(TxRxStatus)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SyncAddrStatus: u8 = unsafe { ::core::mem::transmute(SyncAddrStatus) };
            SyncAddrStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_2 {
    pub RssiPkt: i8,
    pub SnrPkt: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncError: bool,
        LengthError: bool,
        CrcError: bool,
        AbortError: bool,
        HeaderReceived: bool,
        PacketReceived: bool,
        PacketControlerBusy: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncError: u8 = unsafe { ::core::mem::transmute(SyncError) };
            SyncError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LengthError: u8 = unsafe { ::core::mem::transmute(LengthError) };
            LengthError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CrcError: u8 = unsafe { ::core::mem::transmute(CrcError) };
            CrcError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AbortError: u8 = unsafe { ::core::mem::transmute(AbortError) };
            AbortError as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HeaderReceived: u8 = unsafe { ::core::mem::transmute(HeaderReceived) };
            HeaderReceived as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PacketReceived: u8 = unsafe { ::core::mem::transmute(PacketReceived) };
            PacketReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PacketControlerBusy: u8 = unsafe { ::core::mem::transmute(PacketControlerBusy) };
            PacketControlerBusy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    #[inline]
    pub fn RxNoAck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RxNoAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketSent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RxNoAck: bool,
        PacketSent: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RxNoAck: u8 = unsafe { ::core::mem::transmute(RxNoAck) };
            RxNoAck as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PacketSent: u8 = unsafe { ::core::mem::transmute(PacketSent) };
            PacketSent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>())).RssiPkt
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(RssiPkt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>())).SnrPkt
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SnrPkt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>())).ErrorStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ErrorStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_2>())).TxRxStatus
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(TxRxStatus)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SyncAddrStatus: u8 = unsafe { ::core::mem::transmute(SyncAddrStatus) };
            SyncAddrStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_3 {
    pub RssiAvg: i8,
    pub RssiSync: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncError: bool,
        LengthError: bool,
        CrcError: bool,
        AbortError: bool,
        HeaderReceived: bool,
        PacketReceived: bool,
        PacketControlerBusy: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncError: u8 = unsafe { ::core::mem::transmute(SyncError) };
            SyncError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LengthError: u8 = unsafe { ::core::mem::transmute(LengthError) };
            LengthError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CrcError: u8 = unsafe { ::core::mem::transmute(CrcError) };
            CrcError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AbortError: u8 = unsafe { ::core::mem::transmute(AbortError) };
            AbortError as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HeaderReceived: u8 = unsafe { ::core::mem::transmute(HeaderReceived) };
            HeaderReceived as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PacketReceived: u8 = unsafe { ::core::mem::transmute(PacketReceived) };
            PacketReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PacketControlerBusy: u8 = unsafe { ::core::mem::transmute(PacketControlerBusy) };
            PacketControlerBusy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_3__bindgen_ty_2 {
    #[inline]
    pub fn RxPid(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_RxPid(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn RxNoAck(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RxNoAck(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RxPidErr(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RxPidErr(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketSent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RxPid: u8,
        RxNoAck: bool,
        RxPidErr: bool,
        PacketSent: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let RxPid: u8 = unsafe { ::core::mem::transmute(RxPid) };
            RxPid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let RxNoAck: u8 = unsafe { ::core::mem::transmute(RxNoAck) };
            RxNoAck as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RxPidErr: u8 = unsafe { ::core::mem::transmute(RxPidErr) };
            RxPidErr as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let PacketSent: u8 = unsafe { ::core::mem::transmute(PacketSent) };
            PacketSent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>())).RssiAvg
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(RssiAvg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>())).RssiSync
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(RssiSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>())).ErrorStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(ErrorStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_3>())).TxRxStatus
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(TxRxStatus)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SyncAddrStatus: u8 = unsafe { ::core::mem::transmute(SyncAddrStatus) };
            SyncAddrStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_4 {
    pub RssiAvg: i8,
    pub RssiSync: i8,
    pub ErrorStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1,
    pub TxRxStatus: PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_1 {
    #[inline]
    pub fn SyncError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SyncError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LengthError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_LengthError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CrcError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_CrcError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AbortError(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AbortError(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HeaderReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_HeaderReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketReceived(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketReceived(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PacketControlerBusy(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketControlerBusy(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SyncError: bool,
        LengthError: bool,
        CrcError: bool,
        AbortError: bool,
        HeaderReceived: bool,
        PacketReceived: bool,
        PacketControlerBusy: bool,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SyncError: u8 = unsafe { ::core::mem::transmute(SyncError) };
            SyncError as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LengthError: u8 = unsafe { ::core::mem::transmute(LengthError) };
            LengthError as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let CrcError: u8 = unsafe { ::core::mem::transmute(CrcError) };
            CrcError as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AbortError: u8 = unsafe { ::core::mem::transmute(AbortError) };
            AbortError as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let HeaderReceived: u8 = unsafe { ::core::mem::transmute(HeaderReceived) };
            HeaderReceived as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let PacketReceived: u8 = unsafe { ::core::mem::transmute(PacketReceived) };
            PacketReceived as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let PacketControlerBusy: u8 = unsafe { ::core::mem::transmute(PacketControlerBusy) };
            PacketControlerBusy as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_4__bindgen_ty_2 {
    #[inline]
    pub fn PacketSent(&self) -> bool {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PacketSent(&mut self, val: bool) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(PacketSent: bool) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PacketSent: u8 = unsafe { ::core::mem::transmute(PacketSent) };
            PacketSent as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>(),
        5usize,
        concat!(
            "Size of: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>())).RssiAvg
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(RssiAvg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>())).RssiSync
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(RssiSync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>())).ErrorStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(ErrorStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1__bindgen_ty_4>())).TxRxStatus
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(TxRxStatus)
        )
    );
}
impl PacketStatus_t__bindgen_ty_1__bindgen_ty_4 {
    #[inline]
    pub fn SyncAddrStatus(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_SyncAddrStatus(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(SyncAddrStatus: u8) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 3u8, {
            let SyncAddrStatus: u8 = unsafe { ::core::mem::transmute(SyncAddrStatus) };
            SyncAddrStatus as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PacketStatus_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t__bindgen_ty_1>(),
        5usize,
        concat!("Size of: ", stringify!(PacketStatus_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(PacketStatus_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1>())).Gfsk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1),
            "::",
            stringify!(Gfsk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1>())).LoRa as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1),
            "::",
            stringify!(LoRa)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1>())).Flrc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1),
            "::",
            stringify!(Flrc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<PacketStatus_t__bindgen_ty_1>())).Ble as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t__bindgen_ty_1),
            "::",
            stringify!(Ble)
        )
    );
}
#[test]
fn bindgen_test_layout_PacketStatus_t() {
    assert_eq!(
        ::core::mem::size_of::<PacketStatus_t>(),
        12usize,
        concat!("Size of: ", stringify!(PacketStatus_t))
    );
    assert_eq!(
        ::core::mem::align_of::<PacketStatus_t>(),
        4usize,
        concat!("Alignment of ", stringify!(PacketStatus_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PacketStatus_t>())).packetType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t),
            "::",
            stringify!(packetType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<PacketStatus_t>())).Params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PacketStatus_t),
            "::",
            stringify!(Params)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct RxCounter_t {
    pub packetType: RadioPacketTypes_t,
    pub Params: RxCounter_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union RxCounter_t__bindgen_ty_1 {
    pub Gfsk: RxCounter_t__bindgen_ty_1__bindgen_ty_1,
    pub LoRa: RxCounter_t__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: [u16; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RxCounter_t__bindgen_ty_1__bindgen_ty_1 {
    pub PacketReceived: u16,
    pub CrcError: u16,
    pub LengthError: u16,
    pub SyncwordError: u16,
}
#[test]
fn bindgen_test_layout_RxCounter_t__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>())).PacketReceived
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(PacketReceived)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>())).CrcError
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(CrcError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>())).LengthError
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LengthError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_1>())).SyncwordError
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SyncwordError)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RxCounter_t__bindgen_ty_1__bindgen_ty_2 {
    pub PacketReceived: u16,
    pub CrcError: u16,
    pub HeaderValid: u16,
}
#[test]
fn bindgen_test_layout_RxCounter_t__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>())).PacketReceived
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(PacketReceived)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>())).CrcError
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(CrcError)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1__bindgen_ty_2>())).HeaderValid
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(HeaderValid)
        )
    );
}
#[test]
fn bindgen_test_layout_RxCounter_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<RxCounter_t__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(RxCounter_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<RxCounter_t__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(RxCounter_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1>())).Gfsk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1),
            "::",
            stringify!(Gfsk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RxCounter_t__bindgen_ty_1>())).LoRa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t__bindgen_ty_1),
            "::",
            stringify!(LoRa)
        )
    );
}
#[test]
fn bindgen_test_layout_RxCounter_t() {
    assert_eq!(
        ::core::mem::size_of::<RxCounter_t>(),
        12usize,
        concat!("Size of: ", stringify!(RxCounter_t))
    );
    assert_eq!(
        ::core::mem::align_of::<RxCounter_t>(),
        4usize,
        concat!("Alignment of ", stringify!(RxCounter_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RxCounter_t>())).packetType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t),
            "::",
            stringify!(packetType)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<RxCounter_t>())).Params as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(RxCounter_t),
            "::",
            stringify!(Params)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct CalibrationParams_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_CalibrationParams_t() {
    assert_eq!(
        ::core::mem::size_of::<CalibrationParams_t>(),
        1usize,
        concat!("Size of: ", stringify!(CalibrationParams_t))
    );
    assert_eq!(
        ::core::mem::align_of::<CalibrationParams_t>(),
        1usize,
        concat!("Alignment of ", stringify!(CalibrationParams_t))
    );
}
impl CalibrationParams_t {
    #[inline]
    pub fn RC64KEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RC64KEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RC13MEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RC13MEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PLLEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_PLLEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADCPulseEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ADCPulseEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADCBulkNEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ADCBulkNEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ADCBulkPEnable(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ADCBulkPEnable(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RC64KEnable: u8,
        RC13MEnable: u8,
        PLLEnable: u8,
        ADCPulseEnable: u8,
        ADCBulkNEnable: u8,
        ADCBulkPEnable: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RC64KEnable: u8 = unsafe { ::core::mem::transmute(RC64KEnable) };
            RC64KEnable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let RC13MEnable: u8 = unsafe { ::core::mem::transmute(RC13MEnable) };
            RC13MEnable as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PLLEnable: u8 = unsafe { ::core::mem::transmute(PLLEnable) };
            PLLEnable as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let ADCPulseEnable: u8 = unsafe { ::core::mem::transmute(ADCPulseEnable) };
            ADCPulseEnable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ADCBulkNEnable: u8 = unsafe { ::core::mem::transmute(ADCBulkNEnable) };
            ADCBulkNEnable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ADCBulkPEnable: u8 = unsafe { ::core::mem::transmute(ADCBulkPEnable) };
            ADCBulkPEnable as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct SleepParams_t {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_SleepParams_t() {
    assert_eq!(
        ::core::mem::size_of::<SleepParams_t>(),
        1usize,
        concat!("Size of: ", stringify!(SleepParams_t))
    );
    assert_eq!(
        ::core::mem::align_of::<SleepParams_t>(),
        1usize,
        concat!("Alignment of ", stringify!(SleepParams_t))
    );
}
impl SleepParams_t {
    #[inline]
    pub fn WakeUpRTC(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WakeUpRTC(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InstructionRamRetention(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_InstructionRamRetention(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DataBufferRetention(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DataBufferRetention(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DataRamRetention(&self) -> u8 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DataRamRetention(&mut self, val: u8) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        WakeUpRTC: u8,
        InstructionRamRetention: u8,
        DataBufferRetention: u8,
        DataRamRetention: u8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let WakeUpRTC: u8 = unsafe { ::core::mem::transmute(WakeUpRTC) };
            WakeUpRTC as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InstructionRamRetention: u8 =
                unsafe { ::core::mem::transmute(InstructionRamRetention) };
            InstructionRamRetention as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DataBufferRetention: u8 = unsafe { ::core::mem::transmute(DataBufferRetention) };
            DataBufferRetention as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DataRamRetention: u8 = unsafe { ::core::mem::transmute(DataRamRetention) };
            DataRamRetention as u64
        });
        __bindgen_bitfield_unit
    }
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetLoRaBandwidth"]
    pub fn SX1280GetLoRaBandwidth(sx1280: *mut SX1280_t) -> i32;
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetRangingCorrectionPerSfBwGain"]
    pub fn SX1280GetRangingCorrectionPerSfBwGain(
        sx1280: *mut SX1280_t,
        sf: RadioLoRaSpreadingFactors_t,
        bw: RadioLoRaBandwidths_t,
        gain: i8,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_SX1280ComputeRangingCorrectionPolynome"]
    pub fn SX1280ComputeRangingCorrectionPolynome(
        sf: RadioLoRaSpreadingFactors_t,
        bw: RadioLoRaBandwidths_t,
        median: f64,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_SX1280OnDioIrq"]
    pub fn SX1280OnDioIrq(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetRangingRole"]
    pub fn SX1280SetRangingRole(sx1280: *mut SX1280_t, role: RadioRangingRoles_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280Init"]
    pub fn SX1280Init(sx1280: *mut SX1280_t, callbacks: *mut RadioCallbacks_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetPollingMode"]
    pub fn SX1280SetPollingMode(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetInterruptMode"]
    pub fn SX1280SetInterruptMode(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetRegistersDefault"]
    pub fn SX1280SetRegistersDefault(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetFirmwareVersion"]
    pub fn SX1280GetFirmwareVersion(sx1280: *mut SX1280_t) -> u16;
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetOpMode"]
    pub fn SX1280GetOpMode(sx1280: *mut SX1280_t) -> RadioOperatingModes_t;
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetStatus"]
    pub fn SX1280GetStatus(sx1280: *mut SX1280_t) -> RadioStatus_t;
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetSleep"]
    pub fn SX1280SetSleep(sx1280: *mut SX1280_t, sleepConfig: SleepParams_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetStandby"]
    pub fn SX1280SetStandby(sx1280: *mut SX1280_t, mode: RadioStandbyModes_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetFs"]
    pub fn SX1280SetFs(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetTx"]
    pub fn SX1280SetTx(sx1280: *mut SX1280_t, timeout: TickTime_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetRx"]
    pub fn SX1280SetRx(sx1280: *mut SX1280_t, timeout: TickTime_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetRxDutyCycle"]
    pub fn SX1280SetRxDutyCycle(
        sx1280: *mut SX1280_t,
        Step: RadioTickSizes_t,
        NbStepRx: u16,
        RxNbStepSleep: u16,
    );
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetCad"]
    pub fn SX1280SetCad(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetTxContinuousWave"]
    pub fn SX1280SetTxContinuousWave(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetTxContinuousPreamble"]
    pub fn SX1280SetTxContinuousPreamble(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetPacketType"]
    pub fn SX1280SetPacketType(sx1280: *mut SX1280_t, packetType: RadioPacketTypes_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetPacketType"]
    pub fn SX1280GetPacketType(sx1280: *mut SX1280_t) -> RadioPacketTypes_t;
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetRfFrequency"]
    pub fn SX1280SetRfFrequency(sx1280: *mut SX1280_t, frequency: u32);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetTxParams"]
    pub fn SX1280SetTxParams(sx1280: *mut SX1280_t, power: i8, rampTime: RadioRampTimes_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetCadParams"]
    pub fn SX1280SetCadParams(sx1280: *mut SX1280_t, cadSymbolNum: RadioLoRaCadSymbols_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetBufferBaseAddresses"]
    pub fn SX1280SetBufferBaseAddresses(
        sx1280: *mut SX1280_t,
        txBaseAddress: u8,
        rxBaseAddress: u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetModulationParams"]
    pub fn SX1280SetModulationParams(sx1280: *mut SX1280_t, modParams: *mut ModulationParams_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetPacketParams"]
    pub fn SX1280SetPacketParams(sx1280: *mut SX1280_t, packetParams: *mut PacketParams_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetRxBufferStatus"]
    pub fn SX1280GetRxBufferStatus(
        sx1280: *mut SX1280_t,
        payloadLength: *mut u8,
        rxStartBuffer: *mut u8,
    );
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetPacketStatus"]
    pub fn SX1280GetPacketStatus(sx1280: *mut SX1280_t, pktStatus: *mut PacketStatus_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetRssiInst"]
    pub fn SX1280GetRssiInst(sx1280: *mut SX1280_t) -> i8;
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetDioIrqParams"]
    pub fn SX1280SetDioIrqParams(
        sx1280: *mut SX1280_t,
        irqMask: u16,
        dio1Mask: u16,
        dio2Mask: u16,
        dio3Mask: u16,
    );
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetIrqStatus"]
    pub fn SX1280GetIrqStatus(sx1280: *mut SX1280_t) -> u16;
}
extern "C" {
    #[link_name = "\u{1}_SX1280ClearIrqStatus"]
    pub fn SX1280ClearIrqStatus(sx1280: *mut SX1280_t, irq: u16);
}
extern "C" {
    #[link_name = "\u{1}_SX1280Calibrate"]
    pub fn SX1280Calibrate(sx1280: *mut SX1280_t, calibParam: CalibrationParams_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetRegulatorMode"]
    pub fn SX1280SetRegulatorMode(sx1280: *mut SX1280_t, mode: RadioRegulatorModes_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetSaveContext"]
    pub fn SX1280SetSaveContext(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetAutoTx"]
    pub fn SX1280SetAutoTx(sx1280: *mut SX1280_t, time: u16);
}
extern "C" {
    #[link_name = "\u{1}_SX1280StopAutoTx"]
    pub fn SX1280StopAutoTx(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetAutoFS"]
    pub fn SX1280SetAutoFS(sx1280: *mut SX1280_t, enable: u8);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetLongPreamble"]
    pub fn SX1280SetLongPreamble(sx1280: *mut SX1280_t, enable: u8);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetPayload"]
    pub fn SX1280SetPayload(sx1280: *mut SX1280_t, payload: *mut u8, size: u8);
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetPayload"]
    pub fn SX1280GetPayload(
        sx1280: *mut SX1280_t,
        payload: *mut u8,
        size: *mut u8,
        maxSize: u8,
    ) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_SX1280SendPayload"]
    pub fn SX1280SendPayload(
        sx1280: *mut SX1280_t,
        payload: *mut u8,
        size: u8,
        timeout: TickTime_t,
    );
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetSyncWord"]
    pub fn SX1280SetSyncWord(sx1280: *mut SX1280_t, syncWordIdx: u8, syncWord: *mut u8) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetSyncWordErrorTolerance"]
    pub fn SX1280SetSyncWordErrorTolerance(sx1280: *mut SX1280_t, errorBits: u8);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetCrcSeed"]
    pub fn SX1280SetCrcSeed(sx1280: *mut SX1280_t, seed: u16);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetBleAccessAddress"]
    pub fn SX1280SetBleAccessAddress(sx1280: *mut SX1280_t, accessAddress: u32);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetBleAdvertizerAccessAddress"]
    pub fn SX1280SetBleAdvertizerAccessAddress(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetCrcPolynomial"]
    pub fn SX1280SetCrcPolynomial(sx1280: *mut SX1280_t, seed: u16);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetWhiteningSeed"]
    pub fn SX1280SetWhiteningSeed(sx1280: *mut SX1280_t, seed: u8);
}
extern "C" {
    #[link_name = "\u{1}_SX1280EnableManualGain"]
    pub fn SX1280EnableManualGain(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280DisableManualGain"]
    pub fn SX1280DisableManualGain(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetManualGainValue"]
    pub fn SX1280SetManualGainValue(sx1280: *mut SX1280_t, gain: u8);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetLNAGainSetting"]
    pub fn SX1280SetLNAGainSetting(sx1280: *mut SX1280_t, lnaSetting: RadioLnaSettings_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetRangingIdLength"]
    pub fn SX1280SetRangingIdLength(sx1280: *mut SX1280_t, length: RadioRangingIdCheckLengths_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetDeviceRangingAddress"]
    pub fn SX1280SetDeviceRangingAddress(sx1280: *mut SX1280_t, address: u32);
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetRangingRequestAddress"]
    pub fn SX1280SetRangingRequestAddress(sx1280: *mut SX1280_t, address: u32);
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetRangingResult"]
    pub fn SX1280GetRangingResult(
        sx1280: *mut SX1280_t,
        resultType: RadioRangingResultTypes_t,
    ) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_SX1280SetRangingCalibration"]
    pub fn SX1280SetRangingCalibration(sx1280: *mut SX1280_t, cal: u16);
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetRangingPowerDeltaThresholdIndicator"]
    pub fn SX1280GetRangingPowerDeltaThresholdIndicator(sx1280: *mut SX1280_t) -> u8;
}
extern "C" {
    #[link_name = "\u{1}_SX1280RangingClearFilterResult"]
    pub fn SX1280RangingClearFilterResult(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280RangingSetFilterNumSamples"]
    pub fn SX1280RangingSetFilterNumSamples(sx1280: *mut SX1280_t, numSample: u8);
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetFrequencyError"]
    pub fn SX1280GetFrequencyError(sx1280: *mut SX1280_t) -> f64;
}
extern "C" {
    #[link_name = "\u{1}_SX1280ProcessIrqs"]
    pub fn SX1280ProcessIrqs(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280ClearInstructionRam"]
    pub fn SX1280ClearInstructionRam(sx1280: *mut SX1280_t);
}
extern "C" {
    #[link_name = "\u{1}_SX1280ParseHexFileLine"]
    pub fn SX1280ParseHexFileLine(sx1280: *mut SX1280_t, line: *mut libc::c_char) -> i8;
}
extern "C" {
    #[link_name = "\u{1}_SX1280GetHexFileLineFields"]
    pub fn SX1280GetHexFileLineFields(
        sx1280: *mut SX1280_t,
        line: *mut libc::c_char,
        bytes: *mut u8,
        addr: *mut u16,
        num: *mut u16,
        code: *mut u8,
    ) -> i8;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
